<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[机器学习笔记 -- 基于逻辑回归的叶子分类]]></title>
      <url>/2017/12/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E4%BA%8E%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%9A%84%E5%8F%B6%E5%AD%90%E5%88%86%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>这篇博客是针对 Kaggle 竞赛中 <strong><a href="https://www.kaggle.com/c/leaf-classification" target="_blank" rel="noopener">Leaf Classification</a></strong> 而写的，简单说就是一个叶子分类问题。主要涉及方法选择、特征工程、二次分类三个问题，记录下来或许对于类似的分类问题有借鉴作用，仅供参考。<a id="more"></a></p>
<h2 id="二、方法选择"><a href="#二、方法选择" class="headerlink" title="二、方法选择"></a>二、方法选择</h2><p>首先需要选择一种恰当的方法进行分类，考虑到目前我的PC性能以及训练所需要的时间，我决定从常用的统计学习方法选择一种效果较好的。利用题目已经给出的训练集，通过初步筛选，简单调参，除去明显不适合的方法，初步选择以下8种方法作为候选方法，分别为：</p>
<ul>
<li>逻辑回归 LR</li>
<li>线性判别分析 LDA</li>
<li>支持向量机 SVM</li>
<li>朴素贝叶斯 Bayes</li>
<li>K近邻 KNN</li>
<li>随机森林 RF</li>
<li>决策树 DT</li>
<li>梯度提升 GB</li>
</ul>
<p>下面基于已有的训练集对这8种方法进一步分析筛选。题目中给出的训练集总共990份，我将其中600份作为训练集，390份作为测试集，分别用这8种方法进行训练并预测，得到以下结果：<br><img src="1.jpg" width="400px" height="400px"><br><img src="2.jpg" width="400px" height="400px"><br>由上面两张对比图可以看到，LR、LDA、SVM 三种方法准确率最高，LR、Bayes、KNN 三种方法对数损失最小，并且 LR 与其余方法之间有数量级的差距，综合考虑准确率和对数损失，我最终选择了 LR 方法，也就是逻辑回归。值得一提的是，对数损失可以一定程度上反应模型预测的置信程度，尽管 LR、LDA、SVM 三者准确率相当，但是 LR 预测结果的置信度比另外两个高很多。</p>
<h2 id="三、特征工程"><a href="#三、特征工程" class="headerlink" title="三、特征工程"></a>三、特征工程</h2><p>采用逻辑回归方法在现有特征上可以得到的对数损失为 <strong>0.02987</strong>，这是 Kaggle 评测的成绩，显然还需要进一步提取特征。特征工程应该是叶子分类中最重要的过程，我主要从以下三个方面进行。</p>
<h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><p>这是7个类别的叶子形状，如下图：<img src="3.jpg" alt=""><br>由图可见，不同类别的叶子在除去形状不同外，宽度和高度也有明显区别，据此我提取了以下五个特征：</p>
<ul>
<li>宽度 width</li>
<li>高度 height</li>
<li>宽高比 width / height</li>
<li>宽高积 width * height</li>
<li>横纵方向 int(width &gt; height)</li>
</ul>
<h3 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h3><p>进一步，还可以利用 opencv 提取叶子的轮廓特征，关于 opencv 的具体用法看 <strong><a href="https://docs.opencv.org/3.1.0/dd/d49/tutorial_py_contour_features.html" target="_blank" rel="noopener">这里</a></strong> 。我主要提取了以下特征：</p>
<ul>
<li>image moments</li>
<li>area and perimeter</li>
<li>centroid point</li>
<li>convexity</li>
<li>convex hull</li>
<li>contour approximation</li>
</ul>
<p>Image moment 用<strong><a href="https://en.wikipedia.org/wiki/Image_moment" target="_blank" rel="noopener">维基百科的解释</a></strong>就是图片像素灰度的加权平均或者多个moment的函数值，Image moments 可以描述图片的一些特殊属性，如面积、中心点等。</p>
<p>Convexity 就是图像的凸边性，通俗的说就是图像的形状是凹的还是凸的。</p>
<p>Contour approximation 就是用一个多边形去近似图像轮廓，显然如果近似得越好，多边形的顶点数通常就越多，见下图：<br><img src="4.jpg" width="600px" height="200px"></p>
<p>Convex hull 类似于 Contour approximation，不过是用凸包来包围图像轮廓，见下图：<br><img src="5.jpg" width="300px" height="300px"><br>Convex hull 可以提供的特征信息有两个，凸包顶点，轮廓的最低点到凸包的距离，由于不同叶子其凸包具有不同的顶点数，无法直接利用其顶点坐标信息，我这里从 Convex hull 提取了两个特征，凸包顶点个数以及轮廓最低点到凸包的距离之和。<br>图像中心点直接利用坐标即可，moments共24个值，因此从轮廓特征总共提取32个特征。</p>
<h3 id="像素特征"><a href="#像素特征" class="headerlink" title="像素特征"></a>像素特征</h3><p>最后一步，图片的像素信息也是可以提取特征的，这里需要利用 PCA 对图片的像素信息进行降维。最终我保留了15维的信息，也就是提取了15个特征。</p>
<p>通过以上3步，我总共提取了52个新的特征，加上题目原本给出的192个特征，总计244个。然后，利用逻辑回归方法重新训练模型并预测，Kaggle 评测给出的对数损失为 <strong>0.00581</strong>，这个效果在实际应用中已经足够好了。</p>
<h2 id="四、二次分类"><a href="#四、二次分类" class="headerlink" title="四、二次分类"></a>四、二次分类</h2><p>为了进一步提高成绩，我对预测结果进行了更详细地分析，发现以下信息：<br><img src="6.jpg" width="400px" height="400px"><br>这是分类器对id为1304的测试用例做出的预测结果，可以发现最大预测概率也不超过0.5，如果将最大概率对应的类别作为最终的类别，其置信程度显然是不够的，实际上在这里就是错误的。造成这个结果的原因可能是某些类别的叶子相似度太高，以致于分类器难以准确划分。因此，可以考虑对这些“不好”的结果进行二次分类，这里有三个问题，如何衡量预测结果是不好的？用哪些数据作为二次分类的训练数据？二次分类用什么方法训练模型呢？</p>
<p>针对问题一，我是这样考虑的。如果分类器对某一个测试用例的预测结果中，最大预测概率高于0.9或者预测概率高于0.05的类别数少于2，那么将最大预测概率对应的类别作为最终结果是可信的，反之则需要进行二次分类。通过筛选，在所有594个测试用例中，有4个用例是需要进行二次分类的，也就是说其余用例的最大预测概率均在0.9以上。</p>
<p>针对问题二，前一步我们已经得到了需要进行二次分类的测试用例，进一步，针对每一个测试用例找到预测概率大于0.05的类别，将这些类别对应的训练集数据作为二次分类的训练数据。统计之后，一共10个类别，总计100条训练数据。</p>
<p>针对问题三，用什么模型，我尝试过了上面提到的 Bayes、LDA、SVM、RF 等方法，得到的结果均不理想，最后我发现还是逻辑回归效果最好，不仅能够正确进行分类，还大大提高了最大预测概率。</p>
<p>下面是这10个类别对应叶子，汇总如下：<img src="7.jpg" alt=""><br>通过二次分类，得到最终的结果，测试用例总计594个，其中585个测试用例最大预测概率高于0.99，593个高于0.94，只有id为1304的用例最大预测概率为0.81。为了提高竞赛成绩，我这里使用了一个小tricky，将所有预测结果中，最大预测概率对应的类别概率置为1，其余置为0。Kaggle 评测给出最后的对数损失值为<strong>0.0000</strong>，也就是说分类器的准确率为100%。</p>
<h2 id="五、附录"><a href="#五、附录" class="headerlink" title="五、附录"></a>五、附录</h2><h3 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现"></a>1.<a href="https://github.com/zg-diligence/Small_Python/blob/master/leaf_classification/leaf_classification.py" target="_blank" rel="noopener">代码实现</a></h3><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><h3 id="1-Leaf-Classification-第一名方案"><a href="#1-Leaf-Classification-第一名方案" class="headerlink" title="1.Leaf Classification 第一名方案"></a>1.<a href="http://blog.kaggle.com/2017/03/24/leaf-classification-competition-1st-place-winners-interview-ivan-sosnovik/" target="_blank" rel="noopener">Leaf Classification 第一名方案</a></h3>]]></content>
      
        <categories>
            
            <category> 机器学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Django学习笔记 -- Celery的简单使用]]></title>
      <url>/2017/12/12/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Celery%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Celery 是 Python 开发的分布式队列处理器，可以异步、分布式地处理任务，也可以执行定时任务。我们可能在 Django 中执行一些比较耗时的任务，如发邮件，我们总不能等待邮件发送完毕了再响应页面吧，同时有一些任务是需要在后台执行的，如爬虫和服务器缓存更新，这时候 Celery 就是一个不错的选择。<a id="more"></a></p>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>在使用 Celery 的时候我们还需要选择一个中间件，用来保存队列记录、执行记录，作为对 Celery 执行过程的数据支持，可以选择 Django 本身、mongodb 等，这里我们使用的是 <strong><a href="https://redis.io/" target="_blank" rel="noopener">Redis</a></strong>。</p>
<h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><p>首先在<strong><a href="https://github.com/MicrosoftArchive/redis" target="_blank" rel="noopener">这里</a></strong>下载编译好的 Windows 环境下的 Redis ，然后安装并配置环境变量。<br>启动 Redis 服务器，在终端输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure></p>
<h3 id="Python-库安装"><a href="#Python-库安装" class="headerlink" title="Python 库安装"></a>Python 库安装</h3><p>在 python 环境下安装 celery、redis，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install celery</span><br><span class="line">pip install redis</span><br></pre></td></tr></table></figure></p>
<p>以上命令会自动安装相关的依赖包，我用的 celery 版本是 3.1.23，在 python34 和 python35 下运行良好。 </p>
<h3 id="Django-配置"><a href="#Django-配置" class="headerlink" title="Django 配置"></a>Django 配置</h3><p>在 settings.py 所在目录下新建 celery.py 文件，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals <span class="comment"># 必须在最上面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">project_name = os.path.split(os.path.abspath(<span class="string">'.'</span>))[<span class="number">-1</span>]</span><br><span class="line">project_settings = <span class="string">'%s.settings'</span> % project_name</span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, project_settings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化 Celery</span></span><br><span class="line">app = Celery(project_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Django 的 settings 文件配置 Celery</span></span><br><span class="line">app.config_from_object(<span class="string">'django.conf:settings'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Celery 加载所有注册的应用</span></span><br><span class="line">app.autodiscover_tasks(<span class="keyword">lambda</span>: settings.INSTALLED_APPS)</span><br></pre></td></tr></table></figure></p>
<p>为了让项目能够加载这个文件，我们还需要在该目录下的 __init__.py 文件中添加如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app <span class="comment">#引入celery实例对象</span></span><br></pre></td></tr></table></figure></p>
<p>最后在 settings.py 文件中配置 Celery，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Celery 中间件 redis://redis 服务所在的 ip 地址:端口/数据库号</span></span><br><span class="line">BROKER_URL = <span class="string">'redis://localhost:6379'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Celery 结果返回，可用于跟踪结果</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://localhost:6379'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Celery 内容等消息的格式设置</span></span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'application/json'</span>]</span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'json'</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Celery 时区设置，与 settings.py 文件的时区设置保持一致</span></span><br><span class="line">CELERY_TIMEZONE = <span class="string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="耗时任务"><a href="#耗时任务" class="headerlink" title="耗时任务"></a>耗时任务</h3><p>在 Django 项目 app 下 models.py 文件所在目录下建立 tasks.py 文件，你可以将所有需要异步执行、后台执行的代码放在这里。这里摘取我 Django 项目中部分代码片段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery.task <span class="keyword">import</span> task</span><br><span class="line"></span><br><span class="line"><span class="meta">@task(name="weibo_spider_friend")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weibo_spider_friend</span><span class="params">(username, friend)</span>:</span></span><br><span class="line">    <span class="comment"># some spider operations</span></span><br></pre></td></tr></table></figure></p>
<p>函数名上面是 celery 的装饰器 task，name参数是任务的名字，当然还有其他方法，请自行查阅。需要注意的是，<strong>这个函数的参数必须是可 JSON 序列化的数据</strong>，这是因为之前我们在 settings.py 文件中指定了消息内容的类型。<br>然后我们在 views.py 或者 views 文件夹下的视图函数中调用准备好的函数，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ..tasks <span class="keyword">import</span> weibo_spider_friend</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_found_friend_weibo</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># some code</span></span><br><span class="line">    args = &#123;<span class="string">'id'</span>: friend.id, <span class="string">'weibo_ID'</span>: friend.weibo_ID&#125;</span><br><span class="line">    weibo_spider_friend.delay(request.user.username, args)</span><br><span class="line">    <span class="comment"># some code</span></span><br></pre></td></tr></table></figure>
<p>当我们调用这个视图函数的时候就会执行这个任务，在此之前，还有最后一个操作，在确保 Redis 已经启动并且可用的前提下，打开终端输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A django_project_name worker -l info</span><br></pre></td></tr></table></figure></p>
<p>注意是在项目根目录下输入这条指令。运行效果如下，其中 tasks 下是我项目的所有任务集：<br><img src="1.jpg" alt=""></p>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>同样，和前面一样我们需要在 tasks.py 下准备好需要定时执行的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery.task <span class="keyword">import</span> periodic_task</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line"><span class="meta">@periodic_task(run_every=(crontab(minute='*/5')), name="weibo_spider")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weibo_spider</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># some code</span></span><br></pre></td></tr></table></figure></p>
<p>异步任务装饰器参数，name 是任务名字，run_every 定义任务执行时间间隔，具体用法请参考 <strong><a href="http://yshblog.com/blog/164" target="_blank" rel="noopener">这篇博客</a></strong>。<br>分别在两个终端窗口执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">celery -A django_project_name worker -l info</span><br><span class="line">celery -A django_project_name beat -l info</span><br></pre></td></tr></table></figure></p>
<p>第二条命令的执行效果如下，下面发出的三条命令是我项目中三个定时任务：<img src="2.jpg" alt=""></p>
<h2 id="四、Supervisor-amp-amp-Celery"><a href="#四、Supervisor-amp-amp-Celery" class="headerlink" title="四、Supervisor &amp;&amp; Celery"></a>四、Supervisor &amp;&amp; Celery</h2><p>详细请参考 <strong><a href="http://yshblog.com/blog/165" target="_blank" rel="noopener">这篇博客</a></strong>，这是 Linux 下的使用姿势，Windows 下我实在不知呀，感受到了 Windows 对于程序员深深的恶意，正在弃坑中。</p>
<h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><h3 id="1-Django-初步使用-Celery"><a href="#1-Django-初步使用-Celery" class="headerlink" title="1.Django 初步使用 Celery"></a>1.<a href="http://yshblog.com/blog/163" target="_blank" rel="noopener">Django 初步使用 Celery</a></h3><h3 id="2-Django-Celery-定时任务和时间设置"><a href="#2-Django-Celery-定时任务和时间设置" class="headerlink" title="2.Django Celery 定时任务和时间设置"></a>2.<a href="http://yshblog.com/blog/164" target="_blank" rel="noopener">Django Celery 定时任务和时间设置</a></h3><h3 id="3-服务器使用-Supervisor-后台运行-Celery"><a href="#3-服务器使用-Supervisor-后台运行-Celery" class="headerlink" title="3.服务器使用 Supervisor 后台运行 Celery"></a>3.<a href="http://yshblog.com/blog/165" target="_blank" rel="noopener">服务器使用 Supervisor 后台运行 Celery</a></h3>]]></content>
      
        <categories>
            
            <category> Django </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习笔记 -- 基于libsvm的中文文本分类]]></title>
      <url>/2017/12/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%B9%8BSVM/</url>
      <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>SVM 是 Cortes 和 Vapnik 于1995年首先提出的，它在解决小样本 、非线性及高维模式识别问题中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。支持向量机方法是建立在统计学习理论的 VC 维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性和学习能力之间寻求最佳折衷，以期获得最好的泛化能力。<a id="more"></a></p>
<p>libsvm 是台湾大学林智仁博士等开发设计的一个操作简单、易于使用、快速有效的通用 SVM 软件包，可以解决分类问题(C−SVC、ν−SVC)，回归问题(ε−SVR、v−SVR)以及分布估计(one−class-SVM)等问题，提供了线性、多项式、径向基和 S 形函数四种常用的核函数供选择，可以有效地解决多类问题、交叉验证选择参数、对不平衡样本加权、多类问题的概率估计等。libsvm 是一个开源的软件包，不仅提供了 libsvm 的 C++语言的算法源代码，还提供了 Python、Java、R、MATLAB、Perl、Ruby、LabVIEW以及 C#.net 等各种语言的接口，可以方便的在 Windows 或 UNIX 平台下使用，也便于科研工作者根据自己的需要进行改进。</p>
<h2 id="二、预处理"><a href="#二、预处理" class="headerlink" title="二、预处理"></a>二、预处理</h2><h3 id="1-语料准备"><a href="#1-语料准备" class="headerlink" title="1.语料准备"></a>1.语料准备</h3><p>我是使用搜狗实验室的 <strong><a href="http://www.sogou.com/labs/resource/cs.php" target="_blank" rel="noopener">新闻数据</a></strong> 作为学习语料的，这份语料来自搜狐新闻2012年6月—7月期间国内、国际、体育、社会、娱乐等18个频道的新闻数据，提供URL和正文信息，适用于文本分类、事件检测跟踪、新词发现、命令实体识别等任务的学习。</p>
<h3 id="2-分词处理"><a href="#2-分词处理" class="headerlink" title="2.分词处理"></a>2.分词处理</h3><p>分词相关的算法不少，这也是一个可以深入研究的课题，而分词结果的好坏也直接影响后续任务的效果。如果自己没有现成的模型，可以使用公开的分词工具，如 <strong><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">结巴分词</a></strong>，该工具提供了Python、Java、C++等多种安装方式，可自行选择。<strong><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">Github</a></strong> 上有详细的教程，我这里不再重复演示。</p>
<h3 id="3-特征提取"><a href="#3-特征提取" class="headerlink" title="3.特征提取"></a>3.特征提取</h3><p>特征提取是整个文本分类中最关键的一步。虽然 SVM 在高维模式识别上具有优势，但对于文本分类的词库来说，有十几万的词量是很常见的，我们需要把 <strong>对类别区分度高的词</strong> 挑选出来，简单来说，如果一个词语在大多数类别的文章中都频繁出现，那么这个词语对于类别是没有区分度的，相反，如果一个词语仅在少数类别的文本中出现，那么这个词语就是有用的。</p>
<p>特征选择的方式有很多，下面仅对<strong>卡方检验（chi）</strong>做简单介绍，卡方检验的核心思想就是 <strong>利用概率论中的χ²分布来衡量实际值与理论值的差异程度</strong>。举个例子，假设我们有一堆文本，需要判断文本包含某个词语（如吴亦凡）是否与该文本的类别（如娱乐)有关，我们通过简单统计可以得到下面的四格表：</p>
<table>
<thead>
<tr>
<th>组别</th>
<th>属于娱乐</th>
<th>不属于娱乐</th>
<th>合计</th>
</tr>
</thead>
<tbody>
<tr>
<td>不包含吴亦凡</td>
<td>19</td>
<td>24</td>
<td>43</td>
</tr>
<tr>
<td>包含吴亦凡</td>
<td>34</td>
<td>10</td>
<td>44</td>
</tr>
<tr>
<td>合计</td>
<td>53</td>
<td>34</td>
<td>87</td>
</tr>
</tbody>
</table>
<p>观察这个表格，直观上我们可以得到这样一个信息：<strong>包含吴亦凡的文本属于娱乐类别的比例高于对立面</strong>。<br>下面我们首先假设 <strong>文本是否包含吴亦凡</strong> 与 <strong>文本是否属于娱乐类</strong> 是独立的，可以计算随机抽取一个文本，属于<strong>娱乐</strong>类别的概率是 $ （19 + 24） / （19 + 34 + 24 + 10） = 60.9 \% $。那么根据无关假设，我们可计算上述表格中各项数据的理论值，得到下面的四格表：</p>
<table>
<thead>
<tr>
<th>组别</th>
<th>属于娱乐</th>
<th>不属于娱乐</th>
<th>合计</th>
</tr>
</thead>
<tbody>
<tr>
<td>不包含吴亦凡</td>
<td>$43 * 0.609 = 26.2$</td>
<td>$43 * 0.391 = 16.8$</td>
<td>43</td>
</tr>
<tr>
<td>包含吴亦凡</td>
<td>$44 * 0.609 = 26.8$</td>
<td>$44 * 0.391 = 17.2$</td>
<td>44</td>
</tr>
<tr>
<td>合计</td>
<td>53</td>
<td>34</td>
<td>87</td>
</tr>
</tbody>
</table>
<p>下面我们可以通过卡方检验来验证区别其差异有无统计学意义，检验的基本公式如下</p>
<p><center> $ χ² = \sum\frac{(A - T)^2}{T} $ 或 $ χ² = \frac{(ad-bc)^2 n}{(a+b)(a+c)(b+d)(c+d)}$</center><br>其中A为四格表中的实际值，T为对应的理论值，a、b为第一行两个数据，c、d为第二行两个数据。通过计算我们可以得到上述表格的χ²值为10.01。得到χ²值之后，我们可以通过查询卡方分布的临界值表（见附录）判断该值是否合理。自由度计算公式 <strong> V =（行数 -1）* （列数-1）</strong>，显然上述四格表的自由度 V = 1。通过查表得到 P = 0.01 的临界值为 6.63，而10.01 &gt; 6.63，也就是说 <strong>文本是否包含吴亦凡</strong> 与 <strong>文本是否属于娱乐类</strong> 无关的可能性小于$1\% $，独立性假设不成立。 </p>
<p>χ²分布的介绍就到这里，下面回到正题。对应到文本分类中，我们需要计算每个词的 a、b、c、d值：</p>
<ul>
<li>在这个分类下包含这个词的文档数量</li>
<li>不在该分类下包含这个词的文档数量</li>
<li>在这个分类下不包含这个词的文档数量</li>
<li>不在该分类下且不包含这个词的文档数量</li>
</ul>
<p>计算之后，我们可以得到每个分类下每个词的卡方分布值，除去 <strong><a href="https://github.com/zg-diligence/Small_Python/blob/master/code_of_ML/SVM/stop_words.txt" target="_blank" rel="noopener">停用词</a></strong> (对于分类没有帮助的词语)，每个类别取前1000个词（可根据实际情况调整）作为该类别的特征词，然后合并所有类别的特征词，去重，生成特征的唯一id。如下例：</p>
<ul>
<li>1       逐项</li>
<li>2       深市</li>
<li>3       九寨沟</li>
<li>4       岛内</li>
<li>5       期望</li>
<li>…</li>
</ul>
<p>注意，序号从1开始标注，这是libsvm的数据格式要求。</p>
<h3 id="4-生成训练数据"><a href="#4-生成训练数据" class="headerlink" title="4.生成训练数据"></a>4.生成训练数据</h3><p>首先直接给出 libsvm 的数据格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lable1 index1:featureValue1 index2:featureValue2 index3:featureValue3 ... </span><br><span class="line">lable2 index1:featureValue1 index2:featureValue2 index3:featureValue3 ...</span><br></pre></td></tr></table></figure></p>
<p>对应到文本分类上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类别ID 特征序号1:特征值1 特征序号2:特征值2 特征序号3:特征值3...</span><br></pre></td></tr></table></figure></p>
<p>其中特征序号必须是严格升序。那么，这里的特征值是什么呢？可以采用TF-IDF值，详细的介绍看 <strong><a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="noopener">这里</a></strong>。这里仅给出计算公式：</p>
<ul>
<li><p>$ 词频(TF)= \frac{某个词在文章中的出现次数}{文章的总词数}$</p>
</li>
<li><p>$ 逆文档频率(IDF)= log（\frac{语料文本总数}{包含该词的文档数+1}）$</p>
</li>
<li><p>$ TF-IDF = 词频(TF)* 逆文档频率(IDF) $</p>
</li>
</ul>
<p>这样，我们就将文本数据转换为了可训练的 libsvm 数据格式，下面给出一个数据示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+1 1:0.708333 2:1 3:1 4:-0.320755 5:-0.105023 6:-1 7:1 8:-0.419847 9:-1 10:-0.225806 12:1 13:-1 </span><br><span class="line">-1 1:0.583333 2:-1 3:0.333333 4:-0.603774 5:1 6:-1 7:1 8:0.358779 9:-1 10:-0.483871 12:-1 13:1</span><br></pre></td></tr></table></figure></p>
<h2 id="三、libsvm-安装"><a href="#三、libsvm-安装" class="headerlink" title="三、libsvm 安装"></a>三、libsvm 安装</h2><p>这里主要讲一下 windows 下 python 版本的 libsvm 安装，环境如下：</p>
<blockquote>
<ul>
<li>Windows 10 64位</li>
<li>Python 3.5 64位</li>
<li>Visual C++ 14</li>
</ul>
</blockquote>
<p>首先到官网下载 <strong><a href="https://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank" rel="noopener">libsvm 源码</a></strong>，windows目录下已经有编译好的32位动态链接库，如下图</p>
<p><img src="2.jpg" alt=""></p>
<p>但如果你使用的是 <strong>64位</strong> python，就需要自己进行编译了。windows下编译工具 <strong> Visual C++ Tools 2015 </strong>，对应 <strong>python 3.5</strong>。 打开终端 <strong> VS2015 x86 x64 Cross Tools Command Prompt </strong>，进入到下载好的 libsvm 根目录，输入命令：</p>
<blockquote>
<p>nmake -f Makefile.win clean all</p>
</blockquote>
<p>编译之后，得到下图，注意日期：</p>
<p><img src="3.jpg" alt=""></p>
<p>剩下的步骤很简单了，首先将动态链接文件 libsvm.dll 拷贝到系统目录，C:\windows\system32\，然后将python目录下 svm.py 和 svmutil.py 拷贝到你的 python 包目录下。好的，大功告成。</p>
<p><strong>注意</strong>，如果你无法编译64位动态链接文件，<strong><a href="https://github.com/zg-diligence/Small_Python/blob/master/code_of_ML/SVM/libsvm/libsvm.dll" target="_blank" rel="noopener">这里</a></strong> 我已经编译好了，亲自验证 python3.4 和 python3.5 均可以使用，虽然 python3.4 对应的编译环境是 Visual C++ 10。</p>
<h2 id="四、libsvm-使用示例"><a href="#四、libsvm-使用示例" class="headerlink" title="四、libsvm 使用示例"></a>四、libsvm 使用示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(data_path, model_path, param_str=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    function: train model and save it into file</span></span><br><span class="line"><span class="string">    data_path: path of training data</span></span><br><span class="line"><span class="string">    model_path: file path to save the model</span></span><br><span class="line"><span class="string">    param_str: parameter string for training model</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> param_str:</span><br><span class="line">        param_str = <span class="string">'-c 200 -g 9.0e-6 -q'</span></span><br><span class="line"></span><br><span class="line">    y, x = svm_read_problem(data_path)</span><br><span class="line">    svm_prob = svm_problem(y, x)</span><br><span class="line">    svm_param = svm_parameter(param_str)</span><br><span class="line">    model = svm_train(svm_prob, svm_param)</span><br><span class="line">    svm_save_model(model_path, model)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(data_path, modal_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    predict label for unlabel data</span></span><br><span class="line"><span class="string">    data_path: path of testing data</span></span><br><span class="line"><span class="string">    model_path: file_path of the model</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    y, x = svm_read_problem(data_path)</span><br><span class="line">    svm_model = svm_load_model(modal_path)</span><br><span class="line">    p_label, p_acc, p_val = svm_predict(y, x, svm_model)</span><br><span class="line">    <span class="keyword">return</span> p_label, p_acc, p_val</span><br></pre></td></tr></table></figure>
<p>上面仅仅是一个代码示例，详细用法请参考文档说明，根目录和 python 目录下都有 README 文件。</p>
<p>此外，对 tools 目录下的 grid.py 文件用法进行简单说明，这个文件依赖于 svm-train.exe 文件，帮助我们更加快捷的找到最佳训练参数，python 环境下运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python grid.py training_file</span><br></pre></td></tr></table></figure></p>
<p>输出结果中最后一行即为最佳参数，当然你可以根据实际情况对 grid.py 代码进行修改。</p>
<p>另外，windows目录下有一个 svm-scale.exe 可执行文件，用于规范化特征值到指定范围，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svm-scale -l 0 -u 10 -s range_file training_file &gt; training_scale</span><br><span class="line">svm-scale -r range_file testing_file &gt; testing_scale</span><br></pre></td></tr></table></figure></p>
<p>上述两条命令将数据的特征值规范到 0-10 之间，-l、-u 参数是特征值上下界，-s range_file 是将范围存到文件中，便于规范测试数据时使用，-r range_file 即读取范围文件。更详细的用法请查看 libsvm 根目录下 README 文件。 </p>
<h2 id="五、附录"><a href="#五、附录" class="headerlink" title="五、附录"></a>五、附录</h2><h3 id="1-相关代码实现"><a href="#1-相关代码实现" class="headerlink" title="1. 相关代码实现 "></a>1.<strong> <a href="https://github.com/zg-diligence/Small_Python/blob/master/code_of_ML/SVM/svm.py" target="_blank" rel="noopener">相关代码实现</a> </strong></h3><h3 id="2-卡方分布临界值表"><a href="#2-卡方分布临界值表" class="headerlink" title="2. 卡方分布临界值表"></a>2.<strong> 卡方分布临界值表</strong></h3><p><img src="1.jpg" alt="卡方分布临界值表"></p>
<h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><h3 id="1-卡方检验原理及应用"><a href="#1-卡方检验原理及应用" class="headerlink" title="1.卡方检验原理及应用"></a>1.<strong><a href="http://guoze.me/2015/09/07/chi-square/" target="_blank" rel="noopener">卡方检验原理及应用</a></strong></h3><h3 id="2-x2检验（chi-square-test）或称卡方检验"><a href="#2-x2检验（chi-square-test）或称卡方检验" class="headerlink" title="2.x2检验（chi-square test）或称卡方检验"></a>2.<strong><a href="http://www.cnblogs.com/emanlee/archive/2008/10/25/1319569.html" target="_blank" rel="noopener">x2检验（chi-square test）或称卡方检验</a></strong></h3><h3 id="3-基于libsvm的中文文本分类原型"><a href="#3-基于libsvm的中文文本分类原型" class="headerlink" title="3.基于libsvm的中文文本分类原型"></a>3.<strong><a href="http://blog.csdn.net/marising/article/details/5844063" target="_blank" rel="noopener">基于libsvm的中文文本分类原型</a></strong></h3><h3 id="4-TF-IDF与余弦相似性的应用"><a href="#4-TF-IDF与余弦相似性的应用" class="headerlink" title="4.TF-IDF与余弦相似性的应用"></a>4.<strong><a href="http://www.ruanyifeng.com/blog/2013/03/tf-idf.html" target="_blank" rel="noopener">TF-IDF与余弦相似性的应用</a></strong></h3>]]></content>
      
        <categories>
            
            <category> 机器学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文本分类，SVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序及其优化]]></title>
      <url>/2017/05/14/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="一、算法思想"><a href="#一、算法思想" class="headerlink" title="一、算法思想"></a>一、算法思想</h2><p>快速排序算法是对冒泡排序的改进，在冒泡排序中，元素的比较和移动都是在相邻单元中进行的，因此可通过减少总的比较次数和移动次数，增大记录的比较和移动距离，从而提高算法性能。<a id="more"></a>快速排序采用分治策略来减少排序过程中的比较次数，首先将原问题分解为若干个与原问题形似的子问题，然后递归地求解子问题，如果子问题的规模足够小，则直接求解子问题，最后将每一个子问题的解组合成原问题的解。</p>
<h2 id="二、核心实现"><a href="#二、核心实现" class="headerlink" title="二、核心实现"></a>二、核心实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(arr, stack)</span>:</span></span><br><span class="line">    <span class="string">"""called by main sorting function"""</span></span><br><span class="line">    high, low = stack.pop(<span class="number">-1</span>), stack.pop(<span class="number">-1</span>)</span><br><span class="line">    pivot, less_equal, greater = arr[high], [], []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> arr[low:high]:</span><br><span class="line">        <span class="keyword">if</span> x &lt;= pivot:less_equal.append(x)</span><br><span class="line">        <span class="keyword">else</span>:greater.append(x)</span><br><span class="line">    arr[low: high + <span class="number">1</span>] = less_equal + [pivot] + greater</span><br><span class="line">    <span class="keyword">if</span> len(less_equal) &gt; <span class="number">1</span>:</span><br><span class="line">        stack.append(low);stack.append(low + len(less_equal) - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> len(greater) &gt; <span class="number">1</span>:</span><br><span class="line">        stack.append(high - len(greater) + <span class="number">1</span>);stack.append(high)</span><br></pre></td></tr></table></figure>
<p>此函数是所有二路快排核心算法的python实现，供主函数调用，为了防止栈溢出，采用非递归方式实现。参数stack是一个全局变量，保存递归进程中每一个序列的首尾元素下标。此函数默认序列最右端元素为划分点，所以在调用函数之前，必须将划分点交换到序列最右端。</p>
<h2 id="三、划分点选取"><a href="#三、划分点选取" class="headerlink" title="三、划分点选取"></a>三、划分点选取</h2><h3 id="1-选取最右端"><a href="#1-选取最右端" class="headerlink" title="1.选取最右端"></a>1.选取最右端</h3><p>第一种选取方法最简单，直接选取序列左端或者右端的元素，在本例中初始化栈stack后便可直接调用上述函数。相关代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack = [<span class="number">0</span>, len(arr)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">  qsort(arr, stack)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-随机选取"><a href="#2-随机选取" class="headerlink" title="2.随机选取"></a>2.随机选取</h3><p>快排算法中选取划分点的原则是尽可能使划分结果均匀分配，在方法1中我们直接选取序列最右端元素往往会得到一个坏的结果，特别当序列是有序的或者趋近于有序的时候，若采用递归方式实现，则会达到最大递归次数，显然效果是很差的。另外一种方案是随机选取序列中的一个元素作为划分点，这样可以尽可能避免极端情况的出现，实验证明其效果也是可观的。相关代码如果下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack = [<span class="number">0</span>, len(arr)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">  low, high = stack[<span class="number">-2</span>], stack[<span class="number">-1</span>]</span><br><span class="line">  pos = random.randint(low, high)</span><br><span class="line">  arr[pos], arr[high] = arr[high], arr[pos]</span><br><span class="line">  qsort(arr, stack)</span><br></pre></td></tr></table></figure></p>
<p>首先调用标准库随机数产生函数，返回一个序列范围内的元素下标，然后将此元素作为划分点交换到序列最右端，调用核心实现函数即可。</p>
<h3 id="3-两数取异"><a href="#3-两数取异" class="headerlink" title="3.两数取异"></a>3.两数取异</h3><p>另外一种选取划分点的方法是，单向遍历序列元素，选取第一次遇到的两个不同元素中较大或者较小的一个作为划分点，如果序列所有元素均相等，则排序已完成。相关代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stack = [<span class="number">0</span>, len(arr)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">  low, high = stack[<span class="number">-2</span>], stack[<span class="number">-1</span>]</span><br><span class="line">  pos, k = low, low + <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> k &lt;= high:</span><br><span class="line">    <span class="keyword">if</span> arr[k] &gt; arr[pos]:</span><br><span class="line">      pos = k;<span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> arr[k] &lt; arr[pos]:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">     k += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> k == high + <span class="number">1</span>:</span><br><span class="line">    stack.pop(<span class="number">-1</span>); stack.pop(<span class="number">-1</span>); <span class="keyword">continue</span></span><br><span class="line">arr[pos], arr[high] = arr[high], arr[pos]</span><br><span class="line">qsort(arr, stack)</span><br></pre></td></tr></table></figure></p>
<p>如图所示，设置指针k遍历序列，如果遇到一个不等元素则找到划分点，本例中选取两个不同元素中较大者，如果遍历完序列，则该序列已经有序。</p>
<h3 id="4-三数取中"><a href="#4-三数取中" class="headerlink" title="4.三数取中"></a>4.三数取中</h3><p>考虑我们选取划分点的原则，是尽可能使划分结果均匀，那么我们需要尽可能选取序列的中值作为划分点，而三数取中法可以帮助我们以更大的概率选择到序列的中值，具体方法选取序列最左端、最右端、中间位置三个元素的中位数作为划分点。相关代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> mid == <span class="number">-1</span>: mid = (low + high) // <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> arr[mid] &lt;= arr[low] &lt;= arr[high] <span class="keyword">or</span> arr[high] &lt;= arr[low] &lt;= arr[mid]:</span><br><span class="line">	<span class="keyword">return</span> low</span><br><span class="line"><span class="keyword">if</span> arr[low] &lt;= arr[mid] &lt;= arr[high] <span class="keyword">or</span> arr[high] &lt;= arr[mid] &lt;= arr[low]:</span><br><span class="line">	<span class="keyword">return</span> mid</span><br><span class="line"><span class="keyword">if</span> arr[low] &lt;= arr[high] &lt;= arr[mid] <span class="keyword">or</span> arr[mid] &lt;= arr[high] &lt;= arr[low]:</span><br><span class="line">	<span class="keyword">return</span> high</span><br></pre></td></tr></table></figure></p>
<p>该段代码返回三数中位数的下标给调用者。我们只给出选取划分点的代码，主函数和方法二类似，详细代码见附录。</p>
<h3 id="5-九数取中"><a href="#5-九数取中" class="headerlink" title="5.九数取中"></a>5.九数取中</h3><p>三数取中的方法在元素个数不是很大的时候效果比较好，实验证明当序列元素个数在7-40之间时效果较好，而当序列长度大于40时，效果下降，由划分点选取原则我们很容易想到扩大选数范围，则可以更大概率的选到中间值，具体方法是将序列分为8个相等部分，则有两个端点和七个中间点，    三个一组，分别选出中位数，然后选出中位数的中位数作为划分点。相关代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size = high - low + <span class="number">1</span></span><br><span class="line">median_1 = median_of_three(arr, low, low + size // <span class="number">3</span>)</span><br><span class="line">median_2 = median_of_three(arr, low + size // <span class="number">3</span> + <span class="number">1</span>, high - size // <span class="number">3</span>)</span><br><span class="line">median_3 = median_of_three(arr, high - size // <span class="number">3</span> + <span class="number">1</span>, high)</span><br><span class="line"><span class="keyword">return</span> median_of_three(arr, median_1, median_2, median_3)</span><br></pre></td></tr></table></figure></p>
<p>当元素序列小于7时，可以直接采取简单排序方法，如插入排序。</p>
<h2 id="四、划分方法"><a href="#四、划分方法" class="headerlink" title="四、划分方法"></a>四、划分方法</h2><h3 id="1-前后指针法"><a href="#1-前后指针法" class="headerlink" title="1.前后指针法"></a>1.前后指针法</h3><p>前后指针法是通过单向遍历序列对序列元素进行划分操作，以从左向右遍历为例，首先设置两个指 针，第一个指向最左端元素的前一个位置，作为目的指针，另一个指向最左端元素，作为遍历指针。用第二个指针遍历序列元素，如果当前元素大于划分点，则递增遍历指针，否则首先递增目的指针，交换二者指向的元素，然后递增遍历指针，继续遍历序列剩余元素，直到划分完成。相关代码实现(C++)如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot = arr[high];</span><br><span class="line">  <span class="keyword">int</span> distionation = low;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt; high; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt; pivot)</span><br><span class="line">    &#123;</span><br><span class="line">      swap(arr, distionation, i);</span><br><span class="line">      distionation++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, distionation, high);</span><br><span class="line">  <span class="keyword">return</span> distionation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-左右指针交换法"><a href="#2-左右指针交换法" class="headerlink" title="2.左右指针交换法"></a>2.左右指针交换法</h3><p>左右指针交换法同样设置两个指针，不过其使用方法不同，用两个指针分别从序列的两端开始遍历， 左指针遇到大于划分点的元素时停下，右指针遇到小于划分点的元素时停下，交换两个指针指向的元素，然后继续进行遍历，直到两个指针相遇，划分结束。相关代码实现(C++)如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot = arr[low];</span><br><span class="line">  <span class="keyword">int</span> p = low + <span class="number">1</span>, q = high;</span><br><span class="line">  <span class="keyword">while</span>(p &lt;= q)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[p] &lt; pivot &amp;&amp; p &lt;= q) p++;</span><br><span class="line">    <span class="keyword">while</span>(arr[q] &gt;= pivot &amp;&amp; p &lt;= q) q--;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; q)</span><br><span class="line">      swap(arr, p, q);</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, low, q);</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-左右指针赋值法"><a href="#3-左右指针赋值法" class="headerlink" title="3.左右指针赋值法"></a>3.左右指针赋值法</h3><p>在方法2中，每次都是交换两个指针的内容，交换操作相当于三个赋值操作，效率较低，而左右指针赋值法即对此进行的改进，又称为填坑法。两个指针分别从序列两端交替进行遍历，首先取出最右端元素作为划分点，最右端位置空出，即为右坑。左指针向右遍历遇到大于划分点的元素时停下，将指针指向的元素值赋给右坑，则当前位置空出，即为左坑，然后右端指针向左遍历遇到小于划分点的元素时停下，同样赋值给左坑，交替进行，直到两个指针相遇。相关代码实现(C++)如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = arr[low];</span><br><span class="line">  <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[high] &gt;= p &amp;&amp; low &lt; high) high--;</span><br><span class="line">    arr[low] = arr[high];</span><br><span class="line">    <span class="keyword">while</span>(arr[low] &lt; p &amp;&amp; low &lt; high) low++;</span><br><span class="line">    arr[high] = arr[low];</span><br><span class="line">  &#125;</span><br><span class="line">  arr[low] = p;</span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-三路快排"><a href="#4-三路快排" class="headerlink" title="4.三路快排"></a>4.三路快排</h3><p>当序列中有很多相等元素，特别是当这些元素相邻时，可以对上述方法进行改进，即三路快排序，即将元素划分为三个部分，分别小于、等于、大于划分点元素，然后对小于、大于划分点元素的两个序列递归进行排序，而等于部分则已经完成排序。相关代码实现(python)如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stack = [<span class="number">0</span>, len(arr)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">while</span> stack:</span><br><span class="line">  high, low = stack.pop(<span class="number">-1</span>), stack.pop(<span class="number">-1</span>)</span><br><span class="line">  pivot, less, equal, greater =arr[random.randint(low, high)], [], [], []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> arr[low: high + <span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">if</span> x &lt; pivot: less.append(x)</span><br><span class="line">    <span class="keyword">elif</span> x == pivot: equal.append(x)</span><br><span class="line">    <span class="keyword">else</span>:greater.append(x)</span><br><span class="line">  arr[low: high + <span class="number">1</span>] = less + equal + greater</span><br><span class="line">  <span class="keyword">if</span> len(less) &gt; <span class="number">1</span>:</span><br><span class="line">    stack.append(low); stack.append(low + len(less) - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> len(greater) &gt; <span class="number">1</span>:</span><br><span class="line">    stack.append(high - len(greater) + <span class="number">1</span>);stack.append(high)</span><br></pre></td></tr></table></figure></p>
<h2 id="五、性能对比"><a href="#五、性能对比" class="headerlink" title="五、性能对比"></a>五、性能对比</h2><p>首先，通过使用相等序列、正序序列、逆序序列、随机序列、部分重复序列对上述排序函数(不包括C++实现的函数)进行测试，测试集生成方式如下图：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arrays = [[<span class="number">25</span>] * RecordsNum,</span><br><span class="line">	  list(range(RecordsNum)),</span><br><span class="line">	  list(range(RecordsNum, <span class="number">0</span>, <span class="number">-1</span>)),</span><br><span class="line">	  [random.randint(<span class="number">1</span>, <span class="number">10000000</span>) <span class="keyword">for</span> k <span class="keyword">in</span> range(RecordsNum)],</span><br><span class="line">	  [random.randint(<span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> k <span class="keyword">in</span> range(RecordsNum)]]</span><br><span class="line">names = [<span class="string">'same records'</span>,</span><br><span class="line">	 <span class="string">'positive sequence'</span>,</span><br><span class="line">	 <span class="string">'negative sequence'</span>,</span><br><span class="line">	 <span class="string">'random sequence'</span>,</span><br><span class="line">	 <span class="string">'repetited records'</span>]</span><br></pre></td></tr></table></figure></p>
<p>对运行结果进行分析，得到如下性能对比图：<center><img src="1.png" alt=""></center><br>图中每个柱状图从左到右依次为选取右端元素、随机选取、两数取异、三数取中、九数取中、三路快排以及标准库排序函数，纵坐标是函数的相对运行时间，容易看出实验结果符合上述原理分析。<br>然后，我们通过对每一个函数使用不同规模的数据集，测试其运行时间变化曲线，每个函数采集30个点进行模拟分析，数据集生成方式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrays = [[random.randint(<span class="number">1</span>, <span class="number">10000000</span>) <span class="keyword">for</span> k <span class="keyword">in</span> range(standard * m)] <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">91</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure></p>
<p>对运行结果进行分析，得到如下性能曲线图：<center><img src="2.png" alt=""></center><br>我们使用的数据集大小从50000到4500000线性增加，容易看出函数运行时间大致呈线性变化。</p>
<h2 id="六、附录"><a href="#六、附录" class="headerlink" title="六、附录"></a>六、附录</h2><h3 id="1-划分点选取与三路快排-python实现"><a href="#1-划分点选取与三路快排-python实现" class="headerlink" title="1.划分点选取与三路快排 python实现"></a>1.<a href="https://github.com/zg-diligence/blog_contents/blob/master/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/QuickSort_NotRecursion.py" target="_blank" rel="noopener">划分点选取与三路快排 python实现</a></h3><h3 id="2-划分方法-C-实现"><a href="#2-划分方法-C-实现" class="headerlink" title="2.划分方法 C++实现"></a>2.<a href="https://github.com/zg-diligence/blog_contents/blob/master/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/QuickSort.cpp" target="_blank" rel="noopener">划分方法 C++实现</a></h3><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><h3 id="1-关于快速排序的四种写法"><a href="#1-关于快速排序的四种写法" class="headerlink" title="1.关于快速排序的四种写法"></a>1.<a href="https://segmentfault.com/a/1190000004410119" target="_blank" rel="noopener">关于快速排序的四种写法</a></h3><h3 id="2-《算法导论》第二版"><a href="#2-《算法导论》第二版" class="headerlink" title="2.《算法导论》第二版"></a>2.《算法导论》第二版</h3>]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[最短路径算法小结]]></title>
      <url>/2017/04/14/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="一、单源最短路径算法"><a href="#一、单源最短路径算法" class="headerlink" title="一、单源最短路径算法"></a>一、单源最短路径算法</h2><h3 id="1-Bellman-Ford算法"><a href="#1-Bellman-Ford算法" class="headerlink" title="1.Bellman-Ford算法"></a>1.Bellman-Ford算法</h3><h4 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h4><p>Bellman-Ford算法解决的是一般情况下的的单源最短路径问题，边的权值可以为负，并且该算法可以判断有向图中是否有负环。给定有向图G=(V,E)和相应边的权重，同时指定源点，Bellman-Ford算法返回一个布尔值，以表明有向图中是否含有负环，如果没有，算法将给出最短路径及其权重。<a id="more"></a></p>
<h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>假设有向图G有|V|个顶点，那么我们容易知道任意两点之间的最短路径最多有|V|-1边，也就是简单路径，如果大于|V|-1条边，必然有环，如果是正环，去掉后路径变短，如果是负环，最短路不存在，如果是零环，去掉后不变。Bellman-Ford算法的思想很简单，就是对每一条边更新|V|-1次，如果有向图中没有负环，那么总能得到正确结果。<br>那又怎么判断是否有负环呢？在进行|V|-1次松弛操作之后，如果仍然有变化，则再执行一次循环，如果仍然有更新操作发生，则必然含有负环。原因在上一段已经提到，如果有向图中没有负环，得到正确结果至多需要|V|-1次操作。实际上，并不是一定需要|V|-1次松弛操作，如果在某一次操作之后，没有任何更新，则再进行循环也不会有更新了，即当前结果就是最短路径，退出函数即可。<br>补充说明一下什么是松弛操作。假设边(u,v)是图中的一条边，w(u,v)是该边的权重，dist[u]、dist[v]分别代表当前时刻顶点u、v到源点的最短距离，如果dist[u] + w(u,v) &lt; dist[v]，则需要对边(u,v)进行松弛操作，也就是更新顶点v到源点的最短距离。听起来感觉怪怪的。</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>下面给出伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bellman-Ford(G, w, src)</span><br><span class="line">&#123;</span><br><span class="line">  Initialize single source;</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span> to |V|</span><br><span class="line">     <span class="keyword">for</span> each edge(u,v) ∈ G.E</span><br><span class="line">  	 Relax(u, v, w);</span><br><span class="line">     <span class="keyword">if</span> no change</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">if</span> i == |V| <span class="keyword">and</span> change occurs</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>算法第3行初始化操作所需时间为$O(|V|)$，第4-10行每一次循环需要时间$O(|E|)$，且需要|V|次循环，所以总的运行时间为$O(|V|*|E|)$。</p>
<h3 id="2-SPFA算法"><a href="#2-SPFA算法" class="headerlink" title="2.SPFA算法"></a>2.SPFA算法</h3><h4 id="算法概述-1"><a href="#算法概述-1" class="headerlink" title="算法概述"></a>算法概述</h4><p>SPFA算法其实是针对Bellman-Ford的队列改进版，应用范围和Bellman-Ford是一样的。</p>
<h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>容易看出，Bellman-Ford算法中对边的更新并不总是有意义的，对于某一条具体的边，如果它的起始顶点在前一次更新中没有受到影响，那么它在这次循环中也不会更新，所以没有必要对每一条边进行更新。SPFA算法采用一个队列保存受到影响的顶点，初始时刻将源点入队，每一次循环取出队首顶点，找到所有与之相邻的顶点，更新最短路，并将这些受到影响的顶点入队。所谓的受到影响，也就是在某一次更新中，顶点到源点的最短路径发生变化。直到队列为空时，退出循环。<br>接下来的问题是如何判断是否有负环？如果有负环，前面的更新操作将陷入死循环。由于对某一条具体的边我们最多需要进行|V|-1次松弛操作，每一次松弛操作，相应的顶点就会入队，我们可以记录每一个顶点入队的次数，如果存在某一个顶点入队次数达到|V|次，那么有向图中必然有负环，强制退出循环，返回错误信息。</p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><p>下面给出伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SPFA(G, w, src)</span><br><span class="line">&#123;</span><br><span class="line">  Enqueued src <span class="keyword">and</span> Initialize info;</span><br><span class="line">  <span class="keyword">while</span> <span class="built_in">queue</span> is <span class="keyword">not</span> empty</span><br><span class="line">    u = dequeue the <span class="built_in">queue</span></span><br><span class="line">    <span class="keyword">for</span> each edge(u,v) ∈ G.E</span><br><span class="line">        Relax(u, v, w);</span><br><span class="line">    <span class="keyword">if</span> change occurs</span><br><span class="line">	enqueued v;</span><br><span class="line">    <span class="keyword">if</span> v enqueued <span class="keyword">for</span> |V| times</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>算法复杂度同Bellman-Ford算法，$O(|V|*|E|)$。</p>
<h3 id="3-ASP算法"><a href="#3-ASP算法" class="headerlink" title="3.ASP算法"></a>3.ASP算法</h3><h4 id="算法概述-2"><a href="#算法概述-2" class="headerlink" title="算法概述"></a>算法概述</h4><p>ASP算法是针对带权重的有向无环图提出的一种线性算法。在有向无环图中，即使存在负权值的边，但因为没有权重为负值的环，最短路径是存在的。</p>
<h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><p>首先，该算法对有向无环图进行一次拓扑排序，以便确定结点之间的一个线性次序。拓扑排序其实和排序算法没有任何关系，那么它为什么又叫做排序呢？在拓扑序列中有这样一个性质，如果一条边有向边(u,v)在有向图G中，那么在有向图顶点的拓扑序列中，顶点u一定在v之前。具体原因，请参考拓扑排序算法原理。这样一来，我们只需要按照拓扑序列对结点进行一遍处理即可，因为一旦更新某一个顶点，则该顶点即被确定，不会再更新。<br>在对有向图顶点进行拓扑排序的同时，也就判断出有向图中是否包含有环，因为拓扑排序是不能对有环图使用的。</p>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><p>下面给出伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ASP(G, w, r)</span><br><span class="line">&#123;</span><br><span class="line">  topologically sort the vertices of G;</span><br><span class="line">  Initialize single source;</span><br><span class="line">  <span class="keyword">for</span> each vertex u, taken in topologically sorted order</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">	  Relax(u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>复杂度分析非常容易。算法第3行拓扑排序时间为$O(|V|+|E|)$，第4行为$O(|V|)$，第5-7行恰好对每条边松弛一次，即$O(|E|)$。那么总的算法时间为$O(|V|+|E|)$，是线性时间。</p>
<h3 id="4-Dijkstra算法"><a href="#4-Dijkstra算法" class="headerlink" title="4.Dijkstra算法"></a>4.Dijkstra算法</h3><h4 id="算法概述-3"><a href="#算法概述-3" class="headerlink" title="算法概述"></a>算法概述</h4><p>Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。采用合适的方法实现，Dijkstra算法的运行时间要低于Bellman-Ford算法的运行时间。</p>
<h4 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h4><p>Dijkstra算法其实是一种贪心算法。该算法将有向图的顶点分为两个集合，一个是S，包含所有已经确定到源点最短路径的顶点，另一个是V-S，没有确定的顶点集合。算法重复从结点集V-S中选出最短路径估计最小的顶点u加入集合S，然后对所有从u出发的边进行松弛操作，直到S = V。<br>为什么该算法中不能有负权值的边呢？还要强调的一点是，在Djkstra算法中一旦某个顶点已经加入集合S，则在后续更新中不再考虑该顶点。下面举例说明权值为负会出现什么状况：<center><img src="1.jpg" alt=""></center><br>在上图中，源点为a，根据Dijkstra算法首先会选择顶点b，然后才是顶点c，但此时顶点b已经加入集合S，无法再进行更新，那么对于顶点b我们将得到最短路径为5，显然a-&gt;c-&gt;b才是最短路径，权值和为4。</p>
<h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><p>我们可以采用优先队列来维持集合V-S，下面给出算法伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra(G, w, src)</span><br><span class="line">&#123;</span><br><span class="line">  Initialize single source;</span><br><span class="line">  S = ∅;</span><br><span class="line">  Q = G.V;</span><br><span class="line">  <span class="keyword">while</span> Q != ∅</span><br><span class="line">    u = Delete-Min(Q);</span><br><span class="line">    S = S ∪ &#123;u&#125;;</span><br><span class="line">    <span class="keyword">for</span> each vertex v ∈ G.Adj[u]</span><br><span class="line">	  Relax(u, v, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>算法第7行每次Delete-Min操作需要时间$O(1)$，对于每一个顶点只出队一次，算法第9-10隐藏一个Decrease-Key操作，该操作时间为$O(lg|V|)$，一共|E|条边，则总运行时间为$O(|E|*lg|V|)$。</p>
<h2 id="二、全源最短路径算法"><a href="#二、全源最短路径算法" class="headerlink" title="二、全源最短路径算法"></a>二、全源最短路径算法</h2><h3 id="1-基于矩阵乘法的动态规划算法"><a href="#1-基于矩阵乘法的动态规划算法" class="headerlink" title="1.基于矩阵乘法的动态规划算法"></a>1.基于矩阵乘法的动态规划算法</h3><h4 id="算法概述-4"><a href="#算法概述-4" class="headerlink" title="算法概述"></a>算法概述</h4><p>基于矩阵乘法的动态规划算法是用来解决所有结点对最短路径问题的。首先，我们需要知道这样一条引理：一条最短路径的所有子路径都是最短路径。引理的证明请参考《算法导论》引理24.1。考虑从结点u到结点v的一条最短路径p，假定p至多包含m条边，并且有向图中没有负环。如果 u = v，则p的权重为0且不包含任何边。如果u != v，则将路径分解为u~k-&gt;v，其中路径p’:u~k至多包含m-1边，且p’为结点u到k的一条最短路径。因此dist[u][v] = dist[u][k] + w(k,v)。</p>
<h4 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h4><p>设L(m)[u][v]为从结点u到结点v的至多包含m条边的任意路径中的最小权重，对于需要计算的L(m)[u][v]是L(m-1)[u][v]的最小值和从u到v的最多由m条边组成的任意路径的最小权重，我们通过检查j的所有可能前驱来获得该值，也就是说:</p>
<blockquote>
<p><font size="4"> L(m)[u][v] = min { L(m)[u][v], min { L(m-1)[u][k] + w(k,v) }}， 0 &lt;= k &lt;= |V|-1</font></p>
</blockquote>
<p>那么又怎样判断图中是否有负环呢？简单分析可以得出，有向图中有负环当前仅当存在顶点 i，使得 L(m)[i][i] &lt; 0，证明略。此方法介绍比较简略，详细请参考《算法导论》25.1。</p>
<h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><p>边拓展：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXTEND_SHORTEST_PATHS(L, W)  </span><br><span class="line">&#123;</span><br><span class="line">  n = L.rows;</span><br><span class="line">  let L' = l'(i,j) be a <span class="keyword">new</span> n*n matrix;</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span> to n  </span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to n  </span><br><span class="line">      l'(i,j) = ∞</span><br><span class="line">      <span class="keyword">for</span> k = <span class="number">1</span> to n</span><br><span class="line">      l(i,j) = min &#123;l(i,j)', l(i,k) + w(k,j)&#125;</span><br><span class="line">  <span class="keyword">return</span> L';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SLOW-ALL-PATHS-SHORTEST-PATHS(W)  </span><br><span class="line">&#123;</span><br><span class="line">  n = W.rows;</span><br><span class="line">  L[<span class="number">1</span>] = W;</span><br><span class="line">  <span class="keyword">for</span> m = <span class="number">2</span> to n<span class="number">-1</span>  </span><br><span class="line">      let L[m] be a <span class="keyword">new</span> n*n matrix;</span><br><span class="line">      L[m] = EXTEND_SHORTEST_PATHS(L(m<span class="number">-1</span>), W);</span><br><span class="line">  <span class="keyword">return</span> L[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果采用重复平方技巧:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SLOW-ALL-PATHS-SHORTEST-PATHS(W)  </span><br><span class="line">&#123;</span><br><span class="line">  n = W.rows;</span><br><span class="line">  L[<span class="number">1</span>] = W;</span><br><span class="line">  m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> m &lt; n - <span class="number">1</span>  </span><br><span class="line">      let L[<span class="number">2</span>m] be a <span class="keyword">new</span> n*n matrix;</span><br><span class="line">      L[<span class="number">2</span>*m] = EXTEND_SHORTEST_PATHS(L(m), L(m));</span><br><span class="line">      let m = <span class="number">2</span>*m;</span><br><span class="line">  <span class="keyword">return</span> L[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>显然边拓展需要的时间为$O(|V|^3)$，主程序的循环总共|V|次，则总运行时间为$O(|V|^4)$。如果采用重复平方技巧，主程序循环次数为lg|V|，则总运行时间降为$O(|V|^3 * lg|V|)$。</p>
<h3 id="2-Floyd-Washall算法"><a href="#2-Floyd-Washall算法" class="headerlink" title="2.Floyd-Washall算法"></a>2.Floyd-Washall算法</h3><h4 id="算法概述-5"><a href="#算法概述-5" class="headerlink" title="算法概述"></a>算法概述</h4><p>Floyd-Washall算法也是一种动态规划算法，是用来解决全源最短路径问题的。假设顶点u和v是有向图G中的任意两个顶点，如果u和v之前有有向边，则u和v之间有路径，但不一定是最短的，也许经过某些中间点之后会使路径长度更短。我们可以考虑系统地在原路径中间加入每个顶点，然后不断调整当前路径即可。</p>
<h4 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h4><p>假设求顶点vi到顶点vj的最短路径。如果从 vi 到 vj 存在一条长度为L[i][j]的路径，该路径不一定是最短路径，尚需进行 n 次试探。首先考虑路径 (vi, v0, vj) 是否存在。如果存在，则比较 (vi, vj) 和(vi, v0, vj) 的路径长度，取长度较短者为从 vi 到 vj 的中间顶点的序号不大于0的最短路径。<br>假设在路径上再增加一个顶点 v1，也就是说，如果 (vi ,…, v1)和(v1,…, vj) 分别是当前找到的中间顶点的序号不大于0的最短路径，那么(vi,…, v1 ,…, vj)就是有可能是从vi到vj的中间顶点的序号不大于1的最短路径。将它与已经得到的从 vi 到 vj 中间顶点序号不大于0的最短路径相比较，从中选出中间顶点的序号不大于1的最短路径，再增加一个顶点v2，继续进行试探。<br>一般情况下，若 (vi ,…, vk) 和 (vk, …, vj) 分别是从 vi 到 vk 和从 vk 到 vj 的中间顶点序号不大于 k-1 的最短路径，则将 (vi ,…, vk ,…, vj)和已经得到的从 vi到 vj 且中间顶点序号不大于k-1的最短路径相比较，其长度较短者便是从 vi 到 vj 的中间顶点的序号不大于 k 的最短路径。<br>下面是路径长路的迭代公式，且L(0)[i][j] = w(i,j):</p>
<blockquote>
<p><font size="4">L(m)[i][j] = min { L(m-1)[i][j], L(m-1)[i][k] + L(k-1)[k][j] }，0 ≤ k ≤ |V|-1</font></p>
</blockquote>
<p>同样，有向图中有负环当前仅当存在顶点 i，使得 L(m)[i][i] &lt; 0。<br>下面举例说明，有这样一个有向图：<center><img src="2.jpg" alt=""></center><br>初始矩阵：<center><img src="3.jpg" alt=""></center><br>加入结点0后：<center><img src="4.jpg" alt=""></center><br>加入结点1后：<center><img src="5.jpg" alt=""></center><br>加入结点2后：<center><img src="6.jpg" alt=""></center></p>
<h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><p>下面直接给出主要实现并做出相关分析：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k != size; ++k)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != size; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != size; ++j)</span><br><span class="line">      <span class="keyword">if</span> (dist[i][k] + dist[k][j] &lt; dist[i][j])</span><br><span class="line">      &#123;</span><br><span class="line">	     <span class="keyword">if</span> (dist[i][k] == infinity || dist[k][j] == infinity) <span class="comment">//negative weight edge.</span></span><br><span class="line">	        <span class="keyword">continue</span>;</span><br><span class="line">	     dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">	     nextV[i][j] = nextV[i][k];</span><br><span class="line">	     <span class="keyword">if</span> (i == j &amp;&amp; dist[i][j] &lt; <span class="number">0</span>)</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//there is a negative weighted circuit.</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，dist[i][j]代表当前时刻结点i到结点j的路径距离，size是图的顶点个数，nextV是记录路径的数组，请读者自行分析其如何工作的。在程序第10行，对有向图中是否有负环进行了判断。</p>
<h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>显然，Floyd-Washall算法的运行时间为$O(|V|^3)$。</p>
<h3 id="3-Johnson算法"><a href="#3-Johnson算法" class="headerlink" title="3.Johnson算法"></a>3.Johnson算法</h3><h4 id="算法概述-6"><a href="#算法概述-6" class="headerlink" title="算法概述"></a>算法概述</h4><p>Johnson算法是用于解决稀疏图全源最短路径问题的方法。Johnson算法的渐进表现要优于重复平方法和Floyd-Washall算法。Johnson实质上是对有向图每一个顶点调用Dijkstra算法，但是由于Dijkstra算法不能对负权重的边进行操作，调用Dijkstra算法之前需要将有向图转换为符合要求的新的有向图，这需要借助于Bellman-Ford算法。</p>
<h4 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h4><p>具体的算法介绍<a href="http://blog.csdn.net/chenhanzhun/article/details/39084905" target="_blank" rel="noopener">这篇博客</a>已经讲得非常清楚了，所以我就不再介绍了。</p>
<h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><p>下面给出伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JOHNSON(G, w)  </span><br><span class="line">&#123;</span><br><span class="line">  compute G', where G'.V = G.V∪&#123;s&#125;,  </span><br><span class="line">      G'.E = G.V∪&#123;(s,v):v∈G.V&#125;, and  </span><br><span class="line">      w(s,v)=<span class="number">0</span> <span class="keyword">for</span> all v ∈ G.V  </span><br><span class="line">  <span class="keyword">if</span> BELLMAN-FORD(G', w, s) == FALSE  </span><br><span class="line">      print <span class="string">"the input graph contain a negative-weigh cycle"</span>  </span><br><span class="line">  else  for each vertex v ∈ G'.V  </span><br><span class="line">          set h(v) to the value if δ(s,v)  </span><br><span class="line">              computed by the Bellman-Ford algorithm  </span><br><span class="line">        for each edge(u,v)∈G'.E  </span><br><span class="line">            w'(u,v) = w(u,v) + h(u) + h(v); </span><br><span class="line">        let D=&#123;d(u,v)&#125; be a <span class="keyword">new</span> n*n matrix;</span><br><span class="line">        for each vertex u∈G'.V  </span><br><span class="line">            run DIJKSTRA(G,w',u) to compute δ'(u,v) for all δ∈G.V;</span><br><span class="line">            <span class="keyword">for</span> each vertex v∈G.V  </span><br><span class="line">                d(u,v) = δ'(u,v) + h(v) - h(u);</span><br><span class="line">  <span class="keyword">return</span> D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>如果采用二叉堆实现Dijkstra算法，总运行时间为 O(|V||E|lg|V|)，如果采用斐波那契堆来实现Dijkstra算法，则总运行时间为 $O(|V|^2*lg|V| + |V||E|)$。</p>
<h2 id="三、附录"><a href="#三、附录" class="headerlink" title="三、附录"></a>三、附录</h2><h3 id="1-源代码实现"><a href="#1-源代码实现" class="headerlink" title="1.源代码实现"></a>1.<a href="https://github.com/zg-diligence/blog_contents/blob/master/ShortestPath.cpp" target="_blank" rel="noopener">源代码实现</a></h3><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><h3 id="1-带权最短路算法分析"><a href="#1-带权最短路算法分析" class="headerlink" title="1.带权最短路算法分析"></a>1.<a href="https://www.renfei.org/blog/weighted-shortest-path.html" target="_blank" rel="noopener">带权最短路算法分析</a></h3><h3 id="2-所有结点对的最短路径"><a href="#2-所有结点对的最短路径" class="headerlink" title="2.所有结点对的最短路径"></a>2.<a href="http://blog.csdn.net/chenhanzhun/article/details/39084905" target="_blank" rel="noopener">所有结点对的最短路径</a></h3><h3 id="3-算法导论-第二版"><a href="#3-算法导论-第二版" class="headerlink" title="3.算法导论 第二版"></a>3.算法导论 第二版</h3>]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[动态哈夫曼编码压缩]]></title>
      <url>/2017/04/01/%E5%8A%A8%E6%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9/</url>
      <content type="html"><![CDATA[<h2 id="一、算法提出"><a href="#一、算法提出" class="headerlink" title="一、算法提出"></a>一、算法提出</h2><p>由前一篇博客我们可以知道，使用基于静态Huffman编码树的压缩算法对符号流进行编码，必须进行两遍扫描。第一遍扫描统计被编码对象中符号出现的频率，并创建Huffman树，获取具有前缀性质的Huffman编码，第二遍扫描按照已获得的Huffman编码对输入符号进行编码。并且，在存储正文编码结果之前，必须将Huffman树的信息存入压缩文件，上文中我们采用的策略是保存Huffman编码。<a id="more"></a><br>这样的做法，存在一些问题。第一，对于短小的符号流来说，加上Huffman编码信息之后，在尺寸上可能变大，这使得Huffman编码的应用受到限制。第二，静态Huffman编码压缩采用两遍扫描的方式，如果将这种方式用于网络通信中，必然会引起较大的延时，如果用于压缩中，额外的磁盘访问会降低该算法的压缩速度。第三，静态Huffman编码压缩自始至终都采用同一套编码，不能对符号流局部统计变化规律做出反应，压缩效率仍然有提升空间。<br>针对以上问题，有人提出动态Huffman编码方案，又称自适应Huffman。这种方案不需要事先构造Huffman树，而是随着编码的进行，逐步构造Huffman树。同时，这种方法对符号的统计也是动态进行的，意味着能够对符号流局部统计变化规律做出及时的反应，所以说动态Huffman也是一种贪心算法。</p>
<h2 id="二、FGK算法"><a href="#二、FGK算法" class="headerlink" title="二、FGK算法"></a>二、FGK算法</h2><h3 id="1、算法概述"><a href="#1、算法概述" class="headerlink" title="1、算法概述"></a>1、算法概述</h3><p>动态Huffman算法最初由Faller和Galler分别提出，Knuth在1985年改进了这个算法，所以这个标准的动态哈夫曼算法又称做FGK算法。1987年，Vitter提出了一种新的改进算法，并且证明FGK算法编码后的位数T满足：S - n + 1 &lt;= T &lt;= 2S + t -4n +2，而Vitter提出的改进算法编码后的位数T满足：S - n + 1 &lt;= T &lt;= 2S + t -2n +1，其中S是静态哈夫曼算法的编码位数，t是编码文本的长度，n是文本中不相同符号的个数。可见动态哈夫曼编码的最坏情况也不会达到最优化编码的二倍。<br>下面介绍一个定义，一棵二叉树满足兄弟性质当且仅当其满足：</p>
<blockquote>
<p>1、所有叶结点有非负权值，所有内部结点除根结点外都有两个儿子，并且父节点的权值是儿子结点权值之和。<br> 2、对所有结点进行编号，父结点编号比儿子大，并且编号大的结点权值不小于编号小的结点。</p>
</blockquote>
<p>最理想的情况是每一层结点编号从左到右、由下到上满足非递减顺序，但在FGK算法中不总是满足层序性质。实际上只要兄弟结点满足连续编号并且父节点编号大于儿子结点，就能够保证huffman树是正确的。<br>Galler已经证明满足兄弟性质的二叉树即huffman树。<br>上面我们已经提到动态Huffman算法是随着编码进行，逐步构造Huffman树，每读取第t+1个字符时，都是在前t个字符所构造的Huffman树的基础上去更新Huffman树。现在的问题是怎么更新Huffman树才能使其始终满足兄弟性质呢？<br>为了标记一个新符号的出现并且快速添加新的结点，FGK算法设置了一个0-node，即权值为0的结点，我们把它叫做NYT（Not Yet Transmitted）结点。NYT结点编号始终是最小的。初始时刻，二叉树只有一个NYT结点。<br>读取一个字符，如果字符不在Huffman树中，为原来的NYT结点分配两个儿子结点，左儿子作为新的NYT结点，右儿子存储新的符号（权值为1）。然后从旧的NYT结点开始，更新结点以及其所有祖先结点的权值。但是如果直接更新结点权值，会破坏兄弟性质。因此，在更新权值之前，需要进行一个交换操作，找到和当前结点权值相同且编号最大的结点，如果就是当前结点，则当前结点权值直接加1，如果不是，则与当前结点交换，交换后的结点作为当前结点，然后结点权值加1。注意，交换操作是交换以目标节点作为根结点的两棵子树，但是结点编号不变。然后更新当前结点的父结点，重复操作，直到当前结点为根结点。<br>如果符号已经在Huffman树中，则直接更新，方法同上。</p>
<h3 id="2、文件压缩"><a href="#2、文件压缩" class="headerlink" title="2、文件压缩"></a>2、文件压缩</h3><p>编码过程中，每读取一个符号，如果它已经在Huffman树中，直接输出现有编码，然后更新Huffman树；如果不在树中，我们首先把NYT结点编码输出，标记遇到一个未出现过的新符号，紧接着把新符号的二进制编码输出，然后更新Huffman树。算法流程图如下：</p>
<center><img src="1.jpg" alt=""></center>

<p>下面以字符串abcddbb为例，展示每一步的具体操作：<br>1、初始状态，仅有唯一的NYT结点，NYT结点权值为0：</p>
<center><img src="2.jpg" alt=""></center>

<p>2、输入符号a，NYT编码为空，则直接输出a的二进制编码0110 0001，然后新建NYT结点和符号结点，对51号结点进行加一操作：</p>
<center><img src="3.jpg" alt=""></center>

<p>3、输入符号b，NYT编码为0，输出编码0 0110 0010，然后新建NYT结点和符号结点，对49、51号结点进行加一操作：</p>
<center><img src="4.jpg" alt=""></center>

<p>4、输入符号c，NYT编码为00，输出编码00 0110 0011，然后新建NYT结点和符号结点，对47号结点进行加一操作，然后对49号结点进行加一操作，但是49号结点不是块内编号最大的结点，因此需要先与50号结点进行交换操作：</p>
<center><img src="5.jpg" alt=""></center>

<p>5、当前结点更新为50号结点，对50、51号结点进行加一操作：</p>
<center><img src="6.jpg" alt=""></center>

<p>6、输入符号d，NYT编码100，输出编码100 0110 0100，然后新建NYT结点和符号结点，对45号结点进行加一操作，然后对47号结点进行加一操作，但是47号结点不是块内编号最大的结点，因此需要先和49号结点进行交换操作：</p>
<center><img src="7.jpg" alt=""></center>

<p>7、当前结点更新为49号结点，对49、51号结点进行加一操作：</p>
<center><img src="8.jpg" alt=""></center>

<p>8、输入符号d，已经存在，输出编码001，对44号结点进行加一操作，同样需要先与48号结点进行交换操作：</p>
<center><img src="9.jpg" alt=""></center>

<p>9、更新当前结点为48号结点，对48、50、51号结点进行加一操作：</p>
<center><img src="10.jpg" alt=""></center>

<p>10、输入符号b，已经存在，输出编码001，交换44号结点与47号结点：</p>
<center><img src="11.jpg" alt=""></center>

<p>11、对47、50、51号结点进行加一操作：</p>
<center><img src="12.jpg" alt=""></center>

<p>12、输入符号b，已经存在，输出编码10，交换47、49号结点：</p>
<center><img src="13.jpg" alt=""></center>

<p>13、对49、51号结点进行加一操作，至此结束。</p>
<center><img src="14.jpg" alt=""></center>

<p>至于编码串处理和文件写入操作，同静态Huffman压缩算法一样，也是八位一组，需要在文件头保留补0的个数。<br>最后，在<a href="http://www.stringology.org/DataCompression/fgk/index_en.html" target="_blank" rel="noopener">这里</a>可以看到算法伪代码。</p>
<h3 id="3、文件解压"><a href="#3、文件解压" class="headerlink" title="3、文件解压"></a>3、文件解压</h3><p>解压文件时，和编码时一样，动态更新Huffman树，遇到未出现过的字符，则直接输出，同时新建NYT结点和符号结点，更新Huffman树，如果符号已经出现，则直接进行更新操作。<br>由上面的算法流程可知，动态Huffman编码压缩时，无需保存Huffman树的信息，只需要保证编码解码时使用相同的规则即可。此外，由于Huffman树是动态更新的，即使同样的字符，其Huffman编码也不一定相同。</p>
<h2 id="三、Vitter算法"><a href="#三、Vitter算法" class="headerlink" title="三、Vitter算法"></a>三、Vitter算法</h2><h3 id="1、算法概述-1"><a href="#1、算法概述-1" class="headerlink" title="1、算法概述"></a>1、算法概述</h3><p>Vitter算法，又称Algorithm V，是Vitter于1987年发表的（详见J. S. Vitter, “Design and Analysis of Dynamic Huffman Codes,” Journal of the Association for Computing Machinery, Vol. 34, No. 4, October 1987, pp. 825-845.）。尽管Vitter算法并没有提高FGK算法的时间复杂度，但是完全不同的更新方式，使得Huffman编码长度缩短，由上面的介绍可知Vitter算法的下界是优于FGK算法的。同时，为了使该压缩算法在实际压缩过程中能够在线性时间内完成，Vitter提出了一种数据结构，叫做”float tree”，但在附录的源码实现中没有采用此方式。<br>Vitter提出的算法除了满足兄弟性质意外，还必须满足一下两点：</p>
<blockquote>
<p>1、Huffman树中的结点编号必须满足从左到右、由下到上是非递减顺序。<br>  2、对于给定权值，叶子节点所在块在内部结点所在块之前，即如果编号由大到小分配，内部结点块编号大于叶子节点编号。</p>
</blockquote>
<p>说明：我们很容易知道对于满足性质1的Huffman树，相同权值的结点编号一定是连续的，请读者自行体会。<br>作者Vitter在它的论文中是这样说的:</p>
<blockquote>
<p>One of the main features of Algorithm A is its use of implicit numbering in which the nodes in the Huffman tree are numbered in increasing order from bottom to top and at each level in increasing order from left to right. Another main feature is the invariant that all leaves of a given weight precede in the implicit numbering all internal nodes of the same weight. These two features are shown in [3] to guarantee good coding efficiency.</p>
</blockquote>
<p>由性质1、2，我们可以想象，Huffman树中的结点一定是这样的序列：LTLTLTLT，其中L代表叶结点块，T代表内部结点块，并且序列的权值满足非递减顺序。注意，在FGK算法中我们提到了块是权值相等的结点集合，而在Vitter算法中，又分为了叶结点块和内部结点块，这是为了满足性质2，请读者注意区分。<br>由此，Vitter完全抛弃了FGK算法中update策略，下面我们直接给出Vitter算法中update操作的伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">updateHuffmanTree(accept symbol)</span><br><span class="line">&#123;</span><br><span class="line">	pos = pointer of symbol's node;</span><br><span class="line">	<span class="keyword">if</span>(pos == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* a new symbol */</span></span><br><span class="line">		Create <span class="keyword">new</span> NYT node <span class="keyword">and</span> character node, <span class="keyword">and</span> aissgn weight of the character node as <span class="number">1</span>;</span><br><span class="line">		pos = pointer of the old NYT node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* already in the tree */</span></span><br><span class="line">		Swap pos in the tree with leader of its block;</span><br><span class="line">		<span class="keyword">if</span>(pos is the sibling of the NYT node)</span><br><span class="line">		&#123;</span><br><span class="line">			Increase weight of pos;</span><br><span class="line">			pos = parent of pos;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(pos != root of the tree)</span><br><span class="line">		SlideAndIncrement(pos)</span><br><span class="line">	Increase weight of root node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，在FGK算法中，更新主要依靠不断的交换操作来实现的，而在Vitter算法中，采用的是SlideAndIncrement操作。<br>接下来给出SlideAndIncrement操作的伪代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SlideAndIncrement(accept node p)</span><br><span class="line">&#123;</span><br><span class="line">	fp = parent of p;</span><br><span class="line">	wt = p's weight;</span><br><span class="line">	<span class="keyword">if</span>(p is an internal node)</span><br><span class="line">		Slide p in the tree higher than the leaf nodes of weight wt+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		Slide p in the tree higher than the nodes of weight wt;</span><br><span class="line">	p's weight++;</span><br><span class="line">	<span class="keyword">if</span>(p is internal node)</span><br><span class="line">		<span class="keyword">return</span> fp;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> parent of p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的伪代码可知，在FGK算法中，只需要找到块内最大的结点进行交换即可，而在Vitter算法中，需要找到所有满足条件的结点，然后将目标节点滑过指定的结点块。</p>
<h3 id="2、文件压缩-1"><a href="#2、文件压缩-1" class="headerlink" title="2、文件压缩"></a>2、文件压缩</h3><p>下面同样以字符串abcddbb为例，展示每一步的具体操作：<br>1、初始状态,仅有唯一的NYT结点，NYT结点权重为0：</p>
<center><img src="v1.jpg" alt=""></center>

<p>2、输入符号a，NYT编码为空，则直接输出a的二进制编码0110 0001，然后新建NYT结点和符号结点，对51号结点进行加一操作：</p>
<center><img src="v2.jpg" alt=""></center>

<p>3、输入符号b，NYT编码为0，输出编码0 0110 0010，然后新建NYT结点和符号结点:</p>
<center><img src="v3.jpg" alt=""></center>

<p>4、49号结点为内部结点，滑动到50号结点之前，对50号结点进行加一操作，原49号结点为内部结点，下一步从51号结点即根结点开始，根结点直接进行加一操作：</p>
<center><img src="v4.jpg" alt=""></center>

<p>5、输入符号c，NYT编码为10，输出编码10 0110 0011，然后新建NYT结点和符号结点：</p>
<center><img src="v5.jpg" alt=""></center>

<p>6、47号结点为内部结点，滑动到49号结点之前，对49号结点进行加一操作，原47号结点为内部结点，下一步从50号结点开始，无权值为2的叶结点，因此直接对50、51号结点进行加一操作：</p>
<center><img src="v6.jpg" alt=""></center>

<p>7、输入符号d，NYT编码00，输出编码00 0110 0100，然后新建NYT结点和符号结点：</p>
<center><img src="v7.jpg" alt=""></center>

<p>8、45号结点为内部结点，滑动到48号结点之前，对48号结点进行加一操作，原45号结点为内部结点，下一步从49号结点开始，无权值为1的叶结点，因此直接对49、51号结点进行加一操作：</p>
<center><img src="v8.jpg" alt=""></center>

<p>9、输入符号d，已经存在，输出编码111，交换44、47号结点：</p>
<center><img src="v9.jpg" alt=""></center>

<p>10、47号结点为叶结点，滑动到48号之前，对48进行加一操作，原47号是叶结点，下一步从50号结点开始，无权值为3的叶结点，故直接对50、51号结点进行加一操作：</p>
<center><img src="v10.jpg" alt=""></center>

<p>11、输入符号b，已经存在，输出编码01，46号结点为叶结点且编号最大，无须交换，将46号结点滑动到47号结点之前，对47号结点进行加一操作，原46号结点为叶结点，下一步从当前结点的父亲即50号结点开始，对50、51号结点进行加一操作：</p>
<center><img src="v11.jpg" alt=""></center>

<p>12、输入符号b，已经存在，输出编码10，47号结点为叶结点，交换47、48号结点，然后将48号结点滑动到49号结点之前，对49、51号结点进行加一操作，至此结束。</p>
<center><img src="v12.jpg" alt=""></center>

<p>最后，在<a href="http://www.stringology.org/DataCompression/ahv/index_en.html" target="_blank" rel="noopener">这里</a>可以看到算法伪代码。同时，作者给出一个例子，体现出Vitter算法的确是使Huffman树变得更加平衡，缩短了Huffman编码。（其中有一点错误，输入第20个字符后，两种算法得到Huffman树并不完全相同，只是树的高度相等，请读者自行理解。）</p>
<h3 id="3、文件解压-1"><a href="#3、文件解压-1" class="headerlink" title="3、文件解压"></a>3、文件解压</h3><p>同Vitter算法，略。</p>
<h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><h3 id="1、FGK算法源码实现"><a href="#1、FGK算法源码实现" class="headerlink" title="1、FGK算法源码实现"></a>1、<a href="https://github.com/zg-diligence/blog_contents/blob/master/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9/Dy_FGK.h" target="_blank" rel="noopener">FGK算法源码实现</a></h3><h3 id="2、Vitter算法源码实现"><a href="#2、Vitter算法源码实现" class="headerlink" title="2、Vitter算法源码实现"></a>2、<a href="https://github.com/zg-diligence/blog_contents/blob/master/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9/Dy_Vitter.h" target="_blank" rel="noopener">Vitter算法源码实现</a></h3><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><h3 id="1、Quake3-自适应哈夫曼"><a href="#1、Quake3-自适应哈夫曼" class="headerlink" title="1、Quake3 自适应哈夫曼"></a>1、<a href="https://wenku.baidu.com/view/8edaa04cf7ec4afe04a1df1b.html" target="_blank" rel="noopener">Quake3 自适应哈夫曼</a></h3><h3 id="2、Adaptive-Huffman-coding-FGK"><a href="#2、Adaptive-Huffman-coding-FGK" class="headerlink" title="2、Adaptive Huffman coding - FGK"></a>2、<a href="http://www.stringology.org/DataCompression/fgk/index_en.html" target="_blank" rel="noopener">Adaptive Huffman coding - FGK</a></h3><h3 id="3、Adaptive-Huffman-coding-Vitter’s-algorithm-Λ"><a href="#3、Adaptive-Huffman-coding-Vitter’s-algorithm-Λ" class="headerlink" title="3、Adaptive Huffman coding - Vitter’s algorithm (Λ)"></a>3、<a href="http://www.stringology.org/DataCompression/ahv/index_en.html" target="_blank" rel="noopener">Adaptive Huffman coding - Vitter’s algorithm (Λ)</a></h3><h3 id="4、Faller-Gallager-Knuth-Algorithm-FGK"><a href="#4、Faller-Gallager-Knuth-Algorithm-FGK" class="headerlink" title="4、Faller, Gallager, Knuth = Algorithm FGK"></a>4、<a href="https://sites.google.com/site/compgt/fgk" target="_blank" rel="noopener">Faller, Gallager, Knuth = Algorithm FGK</a></h3><h3 id="5、Dynamic-Huffman-Coding-2-Algorithm-Vitter"><a href="#5、Dynamic-Huffman-Coding-2-Algorithm-Vitter" class="headerlink" title="5、Dynamic Huffman Coding 2 - Algorithm Vitter"></a>5、<a href="https://sites.google.com/site/compgt/vitter" target="_blank" rel="noopener">Dynamic Huffman Coding 2 - Algorithm Vitter</a></h3>]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件压缩算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[静态哈夫曼编码压缩]]></title>
      <url>/2017/03/31/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9/</url>
      <content type="html"><![CDATA[<h2 id="一、基本术语"><a href="#一、基本术语" class="headerlink" title="一、基本术语"></a>一、基本术语</h2><ol>
<li><p>WPL：树的带权路径长度，规定为所有叶子结点的带权路径长度之和。</p>
</li>
<li><p>哈夫曼树：给定n个权值作为n个叶子结点，构造的一棵具有最小WPL值的二叉树，又称最优二叉树。</p>
<a id="more"></a></li>
<li><p>编码：将一组对象(如字符集)中的每个对象用唯一的一个二进制位串表示，如ASCII、指令系统。</p>
</li>
<li><p>编码前缀性：如果一组编码中任意一个编码都不是其它任何一个码的前缀 ，则称这种编码具有前缀性， 简称前缀码。</p>
</li>
<li><p>平均编码长度：设每个字符Ci出现的概率为Pi，其二进制编码长度为Li，则$\Sigma Li*Pi$表示该组字符的平均编码长度。</p>
</li>
<li><p>哈夫曼编码：根据字符出现频率构造的具有最小平均编码长度的编码，又称霍夫曼编码，哈夫曼编码是不等长编码，且具有前缀性。</p>
</li>
</ol>
<h2 id="二、二叉哈夫曼编码压缩"><a href="#二、二叉哈夫曼编码压缩" class="headerlink" title="二、二叉哈夫曼编码压缩"></a>二、二叉哈夫曼编码压缩</h2><h3 id="1、哈夫曼树的构造"><a href="#1、哈夫曼树的构造" class="headerlink" title="1、哈夫曼树的构造"></a>1、哈夫曼树的构造</h3><p>举例说明，比如我们要压缩这样一个字符串：</p>
<center> beep boop beer! </center>

<p>首先建立一个字符到次数的映射表，如下图：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>‘b’</th>
<th>‘e’</th>
<th>‘p’</th>
<th>‘ ‘</th>
<th>‘o’</th>
<th>‘r’</th>
<th>‘!’</th>
</tr>
</thead>
<tbody>
<tr>
<td>次数</td>
<td>3</td>
<td>4</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>１</td>
</tr>
</tbody>
</table>
<p>然后，把这些数据放到一个优先队列中，数据项按照权重排序，得到这样一个初始序列：</p>
<center><img src="1.jpg" alt=""></center>

<p>接下来，就是把这个优先队列转换成二叉树，我们始终从优先队列中取出头部的两个元素来构造一棵二叉树，第一个元素作为左结点，第二个作为右结点，并把这两个结点权重之和作为根节点的权重，然后把这颗二叉树放回优先队列中，得到如下图表：</p>
<center><img src="2.jpg" alt=""></center>

<p>同样，再把前两个取出来，形成一个权重为4的结点，然后放回优先队列中：</p>
<center><img src="3.jpg" alt=""></center>

<p>继续算法，得到下图：</p>
<center><img src="4.jpg" alt=""></center><br><center><img src="5.jpg" alt=""></center><br><center><img src="6.jpg" alt=""></center>

<p>最终，得到这样一棵二叉树：</p>
<center><img src="7.jpg" alt=""></center>

<p>此时，把二叉树路径上的左支编码为0，右支编码为1，得到下图：</p>
<center><img src="8.jpg" alt=""></center>

<p>先序遍历二叉树，我们可以得到每一个字符对应的哈夫曼编码，如下表：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>‘b’</th>
<th>‘e’</th>
<th>‘p’</th>
<th>‘ ‘</th>
<th>‘o’</th>
<th>‘r’</th>
<th>‘!’</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>00</td>
<td>11</td>
<td>101</td>
<td>011</td>
<td>010</td>
<td>1000</td>
<td>1001</td>
</tr>
</tbody>
</table>
<p>由上可见，哈夫曼编码是不等长编码，并且具有前缀性，最后我们可以得到Huffman编码：</p>
<blockquote>
<pre><code>0011 1110 1011 0001 0010 1010 1100 1111 1000 1001
</code></pre></blockquote>
<h3 id="2、文件压缩"><a href="#2、文件压缩" class="headerlink" title="2、文件压缩"></a>2、文件压缩</h3><p>假设我们现在的文本是从文件中读取出来的，根据上述原理我们已经获得哈夫曼编码，下一步就是进行编码并写入压缩文件。编码很容易，再次读取文件，将每一个字符转换成对应的Huffman编码，我们可以得到一串01编码，当然不可能直接将这串二进制编码写入压缩文件，在这里，我采取的策略是将8位二进制编码转成对应的ASCII编码，然后把对应的字符写入压缩文件。但是这样做可能会遇到一个问题，编码得到的二进制串的大小不一定被8整除，则最后会余下少于8位的二进制编码串。此时，我们考虑在编码串最后补0，凑足8位，从而可以转换为一个字符。<br>这样我们的确是完成了压缩，可是问题又来了，我们如何去解压这个压缩文件呢？<br>首先，我们在编码串最后补0，解码的时候怎么知道压缩时是否补0或者补了多少个0呢？其次，对于不同的文章，字符出现的次数不一样，得到的哈夫曼树就不一样，因此哈夫曼编码也不一样，我们又按照什么规则去解压呢？<br>针对以上问题，我采用了这样的策略，首先在压缩文件头部用一个字节保存压缩时补0的个数，然后将字符及其对应的哈夫曼编码按一定规则写入文件（即一个字符后面紧跟着其哈夫曼编码），写编码同样按照8位一个字节存储对应字符，然后再将压缩后的内容写入文件。<br>值得注意的是，哈夫曼编码不等长，所以在写入编码之前，需要以最长编码所需要的字节数为准，为每一个编码分配相同大小的字节数，对于哈夫曼码位数不足时，首先补1，剩余位补0。这样做的好处是，在解压时我们可以先读取字符，然后读取相应字节大小并转换为二进制编码，并除去每一个编码的补位，则得到字符对应的Huffman码。我们以第一部分内容为例，易知只需一个字节便可保存每一个编码，补位后得到下图：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>‘b’</th>
<th>‘e’</th>
<th>‘p’</th>
<th>‘ ‘</th>
<th>‘o’</th>
<th>‘r’</th>
<th>‘!’</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>00100000</td>
<td>11100000</td>
<td>10110000</td>
<td>01110000</td>
<td>01010000</td>
<td>10001000</td>
<td>10011000</td>
</tr>
</tbody>
</table>
<p>最后，我们也需要将编码字符的个数以及我们为每一个编码分配的字节数写入压缩文件，即我们需要留下三个字节来保留预处理信息，然后写入Huffman编码表，最后写入压缩文本。<br>考虑上面所有问题，我们得到写入压缩文件字符对应的二进制编码串应该是这样：</p>
<blockquote>
<pre><code>00000000 00000111 000000001 01100010 00100000 01100101 11100000 01110000 10110000 00100000 01110000 01101111 01010000 01110010 10001000 00100001 10011000 00111110 10110001 00101010 11001111 10001001
</code></pre></blockquote>
<p>虽然这里压缩后得到22个字符，看上去不但没有压缩作用，反而放大了，那是因为我们存入了Huffman编码，而且在实际压缩时，文本中字符数肯定远远不止这些。</p>
<h3 id="3、文件解压"><a href="#3、文件解压" class="headerlink" title="3、文件解压"></a>3、文件解压</h3><p>根据压缩原理，我们很容易可以得到解压的方法，首先读出预处理信息，包括压缩文本补0个数、Huffman编码个数、储存每一个编码分配的字节数，然后读取字符及其对应的编码，经简单的恢复处理后得到Huffman编码。<br>根据得到的Huffman编码，我们需要重建Huffman树，以便于译码时遍历哈夫曼树。方法很简单，建立一个二叉树，初始有一个根结点，用每一个Huffman编码去遍历二叉树，如果遍历到叶结点，编码仍未结束，根据编码添加结点，编码为0添加左儿子，反之则添加右儿子，遍历结束，将编码对应字符写到叶结点中。用所有的Huffman码去遍历，最后得到的二叉树即压缩时所建的哈夫曼树。<br>得到哈夫曼树之后，就可以读取压缩文本，转换为对应的二进制编码串，进行译码。译码就是一个遍历二叉树的过程，从根节点出发，遇0则转到左子树，反之转到右子树，直到叶结点，将叶结点中字符写入解压文本，然后再从根结点出发，找下一个字符，直到二进制串结束。当然，我们应该事先将二进制串最后补的0去掉。<br>至此，二叉哈夫曼编码压缩及解压介绍完了，可见由于我们是针对二进制进行编码解码，所以哈夫曼压缩原则上是适用于任意格式文件的，但实际应用中我们只用于压缩文本文件，因为对于图片、音乐、视频文件基本没有压缩作用。</p>
<h2 id="三、K叉哈夫曼编码压缩"><a href="#三、K叉哈夫曼编码压缩" class="headerlink" title="三、K叉哈夫曼编码压缩"></a>三、K叉哈夫曼编码压缩</h2><h3 id="1、哈夫曼树的构造-1"><a href="#1、哈夫曼树的构造-1" class="headerlink" title="1、哈夫曼树的构造"></a>1、哈夫曼树的构造</h3><p>相对于二叉哈夫曼压缩，K叉哈夫曼压缩只是将二进制编码变为K进制，建树时同样采用优先队列，只是每次取出队列前K个结点，建立一棵K叉树，根结点权重为所有子结点之和，然后将根结点放回优先队列中，重复合并，直到队列中只有一个结点，则得到K叉哈夫曼树。<br>可是有一个问题？最后剩下的结点数可能小于K，出现这种情况怎么办呢？<br>首先我们看一看什么情况下能够刚好建成一棵K叉树。假设有n个结点，每次取出K个放回1个，那么易得（K-1）|（n-1)时恰好建成一棵K叉树。也就是说，如果（n-1）%（k-1）！= 0，则需要加入（k-1）-（n-1）%（k-1）个虚结点，等价于第一次只合并（n-1）%（k-1）+ 1个结点。这样问题就得到了解决。<br>举例说明，比如我们要压缩这样一个字符串：</p>
<center> abeep boop ber! </center><br>同样，统计字符出现次数，得到下图：<br><center><img src="13.jpg" alt=""></center>

<p>然后，把这些数据放到一个优先队列中，数据项按照权重排序，得到这样一个初始序列：</p>
<center><img src="14.jpg" alt=""></center>

<p>n = 8，取K = 3，则（n-1）%（K-1）== 1 ！= 0，则应添加一个虚节点，即第一次只合并2个结点，如下图：</p>
<center><img src="9.jpg" alt=""></center>

<p>继续合并：</p>
<center><img src="10.jpg" alt=""></center>

<p>最终，得到这样一棵3叉树：</p>
<center><img src="11.jpg" alt=""></center>

<p>此时，把3叉树路径上同一结点出发的路径从左到右依次编号0、1、2，得到下图：</p>
<center><img src="12.jpg" alt=""></center>

<p>先序遍历3叉树，我们可以得到每一个字符对应的哈夫曼编码，如下表：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>‘b’</th>
<th>‘e’</th>
<th>‘p’</th>
<th>‘ ‘</th>
<th>‘a’</th>
<th>‘o’</th>
<th>‘r’</th>
<th>‘!’</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>22</td>
<td>0</td>
<td>12</td>
<td>21</td>
<td>110</td>
<td>20</td>
<td>111</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>最后容易得到3叉Huffman编码：</p>
<blockquote>
<pre><code>110 22 0 0 12 21 22 20 20 12 21 22 0 111 10
</code></pre></blockquote>
<h3 id="2、文件压缩-1"><a href="#2、文件压缩-1" class="headerlink" title="2、文件压缩"></a>2、文件压缩</h3><p>与二叉哈夫曼编码压缩不同的是，K叉哈夫曼编码压缩得到的是K进制串，不能直接写入压缩文件，需要先转换为二进制编码，即将每一位编码转换为二进制编码，并且所有转换后编码的位数应以最大编码为准。<br>在上例中，采用的是三进制编码，故最大编码为2，需用2个二进制位表示，即0、1、2都应转换为2位二进制码，然后采用与二叉哈夫曼压缩相同策略写入压缩文件，此外K进制压缩预处理信息还应包括进制K。</p>
<h3 id="3、文件解压-1"><a href="#3、文件解压-1" class="headerlink" title="3、文件解压"></a>3、文件解压</h3><p>与二叉哈夫曼类似，只是读取每一位K进制码时，都需要读取多位二进制码，然后转换得到。</p>
<h3 id="4、压缩率"><a href="#4、压缩率" class="headerlink" title="4、压缩率"></a>4、压缩率</h3><p>当K=2时，即二叉哈夫曼压缩，取其余K值均比二叉更差，并且有如下变化规律：</p>
<p><center><img src="15.jpg" alt=""></center><br>由折线图可知，当K成指数增长时，压缩率最好，并且K = 2,4,8,16…依次减弱。这是因为K进制中编码小的也需要用相同大小的二进制位保存，浪费了空间。</p>
<h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><h3 id="1、二叉哈夫曼源码"><a href="#1、二叉哈夫曼源码" class="headerlink" title="1、二叉哈夫曼源码"></a>1、<a href="https://github.com/zg-diligence/blog_contents/blob/master/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9/Huffman.h" target="_blank" rel="noopener">二叉哈夫曼源码</a></h3><h3 id="2、K叉哈夫曼源码"><a href="#2、K叉哈夫曼源码" class="headerlink" title="2、K叉哈夫曼源码"></a>2、<a href="https://github.com/zg-diligence/blog_contents/blob/master/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9/K-Huffman.h" target="_blank" rel="noopener">K叉哈夫曼源码</a></h3><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><h3 id="1、HUFFMAN编码压缩算法"><a href="#1、HUFFMAN编码压缩算法" class="headerlink" title="1、HUFFMAN编码压缩算法"></a>1、<a href="http://coolshell.cn/articles/7459.html" target="_blank" rel="noopener">HUFFMAN编码压缩算法</a></h3>]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件压缩算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++标准库容器deque的简单实现]]></title>
      <url>/2017/03/11/C++%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8%20%E2%80%94%E2%80%94%20Deque/</url>
      <content type="html"><![CDATA[<h2 id="一、deque简介"><a href="#一、deque简介" class="headerlink" title="一、deque简介"></a>一、deque简介</h2><p>deque是双向开口的连续性存储空间。虽说是连续性存储空间，但这种连续性只是表面上的，实际上它的内存是动态分配的，它在堆上分配了一块一块的动态储存区，每一块动态存储区本身是连续的，deque自身的机制把这一块一块的存储区虚拟地连在一起。<br><a id="more"></a>它首次插入一个元素，默认会动态分配一块区域，用完之后再分配下一块动态存储区，然后虚拟地连在一起。deque的这种设计使得它具有比vector复杂得多的架构、算法和迭代器设计。它的性能损失比之vector，是几个数量级的差别。所以说，deque要慎用。</p>
<h2 id="二、deque数据结构图示"><a href="#二、deque数据结构图示" class="headerlink" title="二、deque数据结构图示"></a>二、deque数据结构图示</h2><h3 id="逻辑数据结构示意图："><a href="#逻辑数据结构示意图：" class="headerlink" title="逻辑数据结构示意图："></a>逻辑数据结构示意图：</h3><center><img src="逻辑结构.jpg" alt=""></center>

<h3 id="实际数据结构示意图："><a href="#实际数据结构示意图：" class="headerlink" title="实际数据结构示意图："></a>实际数据结构示意图：</h3><center><img src="实际结构.jpg" alt=""></center>


<h2 id="三、deque数据结构实现"><a href="#三、deque数据结构实现" class="headerlink" title="三、deque数据结构实现"></a>三、deque数据结构实现</h2><h3 id="中控器"><a href="#中控器" class="headerlink" title="中控器"></a>中控器</h3><p>在标准库中，deque先用一段小的连续空间即中控器，顺序存放了一个一个指针，然后这些顺序存放的指针再各自指向用来真正存放数据的连续性空间。当中控器使用率满载时，就会另觅一块更大的连续性空间，然后把指针一个一个复制过去，并销毁旧的空间。利用这种数据结构，deque就能方便地模拟自身的存储区是连续性空间的假象，并且可以实现双向插入删除的功能。我们来看一下示意图：</p>
<center><img src="控制单元.jpg" alt=""></center>

<p>如图所示，map指向的连续空间存放各缓冲区指针，每一个指针指向一块存放数据的连续性空间。<br>在本博客的实现中，采取的策略大同小异，只是用链表代替了中控器中的连续存储空间，链表中每一个结点保存所指向的连续性存储空间首指针和相邻缓冲区结点指针，便于前后移动寻找缓冲区元素，下面是中控器数据结构实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	object *buffer;	<span class="comment">//连续性存储区域首指针</span></span><br><span class="line">	map_node *pre;	<span class="comment">//前一个相邻缓冲区结点指针</span></span><br><span class="line">	map_node *next;	<span class="comment">//后一个相邻缓冲区结点指针</span></span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map_node *left = <span class="literal">nullptr</span>;	<span class="comment">//最左侧结点指针</span></span><br><span class="line">    map_node *right = <span class="literal">nullptr</span>;	<span class="comment">//最右侧结点指针</span></span><br><span class="line">    object *first = <span class="literal">nullptr</span>;	<span class="comment">//第一个元素指针</span></span><br><span class="line">    object *last = <span class="literal">nullptr</span>;		<span class="comment">//最后一个元素指针</span></span><br><span class="line">    <span class="keyword">size_t</span> theSize = <span class="number">0</span>;			<span class="comment">//deque的大小</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如图所示，本文默认每一个缓冲区的大小为10个元素，在deque类的私有成员中包括了首尾缓冲区结点指针和首尾元素指针。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>在标准库中，我们可以通过解引用的方式得到迭代器所指的值，为了能够从“deque内部结构”中得到中某个元素的确切位置，那么deque的迭代器应该具备怎么结构，我们可以考虑以下几点。首先，需要知道该元素位于哪个缓冲区的哪个位置；其次，一旦迭代器前进和后退有可能会跳跃至上一个或下一个缓冲区，为了判断跳跃的条件就需要知道，当前元素所在缓冲区的首尾指针。最后，如果前进或后退必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握中控器的信息，通过中控器可以知道跳跃的缓冲区。所以，在迭代器中至少需要定义如下参数：</p>
<blockquote>
<p>1、当前元素的指针<br>2、当前元素所在缓冲区的首尾指针<br>3、中控器中指向所在缓冲区的指针</p>
</blockquote>
<p>我们再来看一看示意图：</p>
<center><img src="迭代器.jpg" alt=""></center>

<p>下面是迭代器数据结构实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	......</span><br><span class="line">	object *elem = <span class="literal">nullptr</span>;		<span class="comment">//当前元素指针</span></span><br><span class="line">	object *buf = <span class="literal">nullptr</span>;		<span class="comment">//当前缓冲区首指针</span></span><br><span class="line">	map_node *nod = <span class="literal">nullptr</span>;	<span class="comment">//当前缓冲区在中控器中的结点指针</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><p>1、<a href="https://github.com/zg-diligence/blog_contents/blob/master/C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/Deque.h" target="_blank" rel="noopener">Deque代码实现</a></p>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><p>1、<a href="http://www.charleshouserjr.com/Cplus2.pdf" target="_blank" rel="noopener">C++ Primer,5th Edition</a><br>2、<a href="http://www.itdadao.com/articles/c15a312057p0.html" target="_blank" rel="noopener">深入剖析deque容器</a></p>
]]></content>
      
        <categories>
            
            <category> C++学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++标准库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10种常见的排序方法总结]]></title>
      <url>/2017/02/25/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>本文简要总结了常见的10种排序算法，分别从算法思想、算法流程、算法性能、算法优化等方面进行了阐述。在这10种算法中，前面7种是基于比较的算法，后三种是非比较线性算法。本文所有排序除堆排序外，均默认为从小到大。此外，在文末附有我GitHub上的Python实现链接。</p>
<a id="more"></a>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a><strong>1.冒泡排序</strong></h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>将待排序的记录看做是竖着排列的气泡,关键字较小的记录比较轻,从而要往上浮.</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、比较相邻的元素,如果下层元素小于上层元素,则交换;<br>2、从底层向上,对每一对相邻元素重复步骤一,直到当前序列顶端;<br>3、每一轮交换之后,序列元素除去顶端元素,对剩余序列元素重复以上操作;<br>4、若当前序列只有一个元素,排序结束.</p>
<h3 id="算法性能"><a href="#算法性能" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(n^2)$,空间$O(1)$ 算法稳定</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>记录某次遍历时最后发生数据交换的位置,这个位置之后的数据显然已经有序,不用再排序了.因此通过记录最后发生数据交换的位置就可以确定下次循环的范围,此位置初始化为待排序序列顶层元素位置.</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始代码：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != n<span class="number">-1</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j != i; --j)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">                arr[j<span class="number">-1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进后的冒泡排序:  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort_imp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != n<span class="number">-1</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> next = n - <span class="number">1</span>;  <span class="comment">//标记最后一次数据交换的位置,初始化为顶层元素位置;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j != i; --j)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">                arr[j<span class="number">-1</span>] = tmp;</span><br><span class="line">                next = j;</span><br><span class="line">            &#125;</span><br><span class="line">        i = next;  <span class="comment">//更新下一轮排序的序列范围;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a><strong>2.快速排序</strong></h2><h3 id="思考改进"><a href="#思考改进" class="headerlink" title="思考改进"></a>思考改进</h3><p>快速排序算法是对冒泡排序的改进，在冒泡排序中，元素的比较和移动都是在相邻单元中进行的，因此可通过减少总的比较次数和移动次数，增大记录的比较和移动距离，提高算法性能.</p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>分治策略 —— 减少排序过程中的比较次数<br>1、分解:将原问题分解为若干个与原问题形似的子问题;<br>2、求解:递归地求解子问题,若子问题规模足够小,则直接求解子问题;<br>3、组合:将每一个子问题的解组合成原问题的解.</p>
<h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、选取基准元素;<br>2、划分:比基准元素小的放在左边,大于等于放在右边;<br>3、对左右区间递归执行步骤1、2,直至各区间只有一个元素或者序列规模足够小.</p>
<h3 id="基准元素选取"><a href="#基准元素选取" class="headerlink" title="基准元素选取"></a>基准元素选取</h3><p>方法1:取序列最左端元素;<br>方法2:从序列arr[i],…,arr[j]中,将arr[i],arr[(i+j)/2],arr[j]排序,返回中值;<br>方法3:从序列arr[i],…,arr[j]中,选择最先找到的两个不同关键字中的较大者.若无两个关键字不同,则已经有序.</p>
<h3 id="算法性能-1"><a href="#算法性能-1" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(nlogn)$,空间$O(logn)$ 算法不稳定</p>
<h3 id="算法优化-1"><a href="#算法优化-1" class="headerlink" title="算法优化"></a>算法优化</h3><p>1、若采用方法1,当初始序列是非递减序列时,快排性能下降到最坏情况$O(n^2)$,基准元素选取策略可采用方法2;<br>2、在规模较小的情况下,采用直接插入排序.</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换数组两个元素;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基准元素选取,方法3;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPivot_1</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>; k &lt;= j; ++k)</span><br><span class="line">        <span class="keyword">if</span>(arr[k] &gt; arr[i])</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[k] &lt; arr[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//排序已完成;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基准元素选取,方法2;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPivot_2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (i + j) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; arr[j])</span><br><span class="line">        mySwap(i, j, arr);</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] &gt; arr[j])</span><br><span class="line">        mySwap(mid, j, arr);</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; arr[mid])</span><br><span class="line">        mySwap(i, mid, arr);</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//划分元素,小于放在左边,大于等于放在右边;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> pivot, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=i, right=j;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[left] &lt; pivot)left++;</span><br><span class="line">        <span class="keyword">while</span>(arr[right] &gt;= pivot)right--;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[right];</span><br><span class="line">            arr[right] = arr[left];</span><br><span class="line">            arr[left] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotPos = findPivot_1(i, j, arr);</span><br><span class="line">    <span class="keyword">if</span>(pivotPos != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[pivotPos];</span><br><span class="line">        <span class="keyword">int</span> k = partition(i, j, pivot, arr);</span><br><span class="line">        quickSort(i, k<span class="number">-1</span>, arr);</span><br><span class="line">        quickSort(k, j, arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进后的快速排序算法;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort_imp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j - i &lt;= <span class="number">5</span>)</span><br><span class="line">        insertSort(i, j, arr);       <span class="comment">//序列规模小,采用直接插入排序;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[findPivot_2(i, j, arr)];    <span class="comment">//选取基准元素;</span></span><br><span class="line">        <span class="keyword">int</span> k = partition(i, j, pivot, arr);   <span class="comment">//划分元素;</span></span><br><span class="line">        quickSort_imp(i, k<span class="number">-1</span>, arr);   <span class="comment">//对左右序列递归求解问题;</span></span><br><span class="line">        quickSort_imp(k, j, arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//quickSort(0,arr.size()-1,arr);</span></span><br><span class="line">    quickSort_imp(<span class="number">0</span>,arr.size()<span class="number">-1</span>,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a><strong>3.插入排序</strong></h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>依次选取一个待排序的元素,在已排序序列中从后向前扫描,找到相应位置并插入.</p>
<h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、从第一个元素开始,该元素可认为已经排好序;<br>2、取出待排序序列第一个元素,即已排序序列后一个元素;<br>3、在已排序序列中从后往前扫,如果被扫描元素大于新元素,则将该元素后移一位;<br>4、重复步骤3,直到找到一个小于等于目标值的元素,将元素插入在其后面;<br>5、重复步骤2-4,直到待排序序列只有一个元素,则排序完成.</p>
<h3 id="算法性能-2"><a href="#算法性能-2" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(n^2)$,空间$O(1)$ 算法稳定</p>
<h3 id="算法优化-2"><a href="#算法优化-2" class="headerlink" title="算法优化"></a>算法优化</h3><p>直接插入排序每次寻找插入位置时,是按顺序依次往前找,可采用二分查找改进,即折半插入.折半插入的时间复杂度降为$O(nlogn)$;</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i!= arr.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> tmp =arr[i];</span><br><span class="line">        <span class="keyword">for</span>(; j !=<span class="number">0</span> &amp;&amp; tmp &lt; arr[j<span class="number">-1</span>]; --j)</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//折半插入;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort_imp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i != arr.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>, high = i<span class="number">-1</span>, mid;</span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tmp &lt; arr[mid])</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j != low; --j)</span><br><span class="line">                arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            arr[low] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a><strong>4.希尔排序</strong></h2><h3 id="思考改进-1"><a href="#思考改进-1" class="headerlink" title="思考改进"></a>思考改进</h3><p>希尔排序是对直接插入排序的改进,若排序序列基本有序时,直接插入排序的效率可以大大提高,同时由于直接插入排序算法简单,当待排序序列数量较小时效率也很高.</p>
<h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>将整个待排序记录分割成若干个子序列,在子序列中分别进行直接插入排序,当整个序列中的记录基本有序时,对全体记录进行直接插入排序.如何分割子序列是希尔排序的关键,不同的分割策略,算法的效率亦不同.</p>
<h3 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、选取合适的gap(&lt;n),将全部元素分割成gap个子序列,所有相距为gap个元素放入同一个子序列;<br>2、对每一个子序列进行直接插入排序;<br>3、缩小间隔gap,例如 gap=gap/2;<br>4、重复步骤1-3,直到gap=1,将所有元素放入同一个序列中进行直接插入排序,排序结束.</p>
<h3 id="算法性能-3"><a href="#算法性能-3" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(nlogn)$~$O(n^2)$,空间$O(1)$ 算法不稳定</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d=arr.size()/<span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d; i != arr.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            <span class="keyword">for</span>(; j &gt;= d &amp;&amp; tmp &lt; arr[j-d]; j -= d)</span><br><span class="line">                arr[j] = arr[j-d];</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.选择排序"></a><strong>5.选择排序</strong></h2><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><p>每趟排序在当前待排序序列中选取关键字最小或最大的记录,添加到有序序列中.</p>
<h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、在待排序序列中找到最小（大）元素,存放到排序序列的末尾;<br>2、重复步骤1,直到待排序序列只有一个元素,排序结束.</p>
<h3 id="算法性能-4"><a href="#算法性能-4" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(n^2)$,空间$O(1)$ 排序不稳定</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i != right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minPos=i;</span><br><span class="line">        <span class="keyword">int</span> minValue=arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j != right + <span class="number">1</span>; ++j)   <span class="comment">//找出当前序列中的最小元素;</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; minValue)</span><br><span class="line">            &#123;</span><br><span class="line">                minPos = j;</span><br><span class="line">                minValue = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(minPos!=i)    <span class="comment">//将找到的最小元素放到已排序序列末端;</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[minPos] = arr[i];</span><br><span class="line">            arr[i] = minValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    selectionSort(<span class="number">0</span>, arr.size()<span class="number">-1</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a><strong>6.堆排序</strong></h2><h3 id="思考改进-2"><a href="#思考改进-2" class="headerlink" title="思考改进"></a>思考改进</h3><p>堆排序是对直接选择排序的改进,直接选择排序每一次排序是找出待排序序列中的关键字值最小的记录,如果在此同时也找出关键字值较小的记录,则可以减少后面选择中所用的比较次数,从而提高效率.</p>
<h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><p>将待排序的记录序列用完全二叉树表示,然后构造最小堆或者最大堆,移除堆顶元素,再将剩余元素整理成堆,重复步骤直至堆中只有一个元素,则排序完成.</p>
<h3 id="算法流程-5"><a href="#算法流程-5" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、将待排序的记录序列用完全二叉树表示;<br>2、初始化建堆,依次对n/2,…,2,1,0元素执行pushDown操作;<br>3、交换堆顶元素与下标最大的叶结点,将剩余n-1个元素整理成堆;<br>4、重复执行步骤3,直至堆中只有一个元素,则排序完成.</p>
<h3 id="算法性能-5"><a href="#算法性能-5" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(nlogn)$,空间$O(1)$ 算法不稳定</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dev(arr.size()+<span class="number">1</span>);      <span class="comment">//个人习惯从下标为1开始建堆,这不是必须的操作,故不计此开销;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i!=arr.size()+<span class="number">1</span>; ++i)  <span class="comment">//建立完全二叉树;</span></span><br><span class="line">        dev[i]=arr[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.size()/<span class="number">2</span>; i&gt;=<span class="number">1</span>; --i)  <span class="comment">//建立最小堆;</span></span><br><span class="line">        pushDown(i,arr.size(),dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.size(); i&gt;=<span class="number">2</span>; --i)    <span class="comment">//交换元素,将剩余元素整理成堆;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = dev[<span class="number">1</span>];</span><br><span class="line">        dev[<span class="number">1</span>] = dev[i];</span><br><span class="line">        dev[i] = tmp;</span><br><span class="line">        pushDown(<span class="number">1</span>,i<span class="number">-1</span>,dev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i!=arr.size()+<span class="number">1</span>; ++i)  <span class="comment">//复制回初始数组;</span></span><br><span class="line">        arr[i<span class="number">-1</span>]=dev[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a><strong>7.归并排序</strong></h2><h3 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h3><p>将若干个有序序列逐步归并,最终得到一个有序序列.</p>
<h3 id="算法流程-6"><a href="#算法流程-6" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、自底向上 非递归算法 将一个具有n个记录的待排序序列看成n个长度为1的有序序列,进行两两归并,得到[n/2]个长度为2的有序序列,再进行两两归并,得到[n/4]个长度为4的有序序列,重复该步骤,直到得到一个长度为n的有序序列.<br>2、自顶向下 分治算法(递归) 将待排序序列一分为二,分裂点mid=(low+high)/2,递归地对序列arr[low],…,arr[mid]和arr[mid+1],…,arr[high]进行归并排序,然后合并两个子序列.递归终止条件,子序列长度为1.</p>
<h3 id="算法性能-6"><a href="#算法性能-6" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(nlogn)$,空间$O(n)$ 算法稳定</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二路归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arrA, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arrB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注:此函数将合并段结果储存在arrB数组中;</span></span><br><span class="line">    <span class="keyword">int</span> i = start, j = mid + <span class="number">1</span>, k = start;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end)</span><br><span class="line">        arrB[k++] = arrA[i] &lt;= arrA[j] ? arrA[i++] : arrA[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">        arrB[k++] = arrA[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= end)</span><br><span class="line">        arrB[k++] = arrA[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上的非递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergePass</span><span class="params">(<span class="keyword">int</span> h, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arrA, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arrB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i+<span class="number">2</span>*h<span class="number">-1</span> &lt; arrA.size(); i += <span class="number">2</span>*h)</span><br><span class="line">        merge(i, i+h<span class="number">-1</span>, i+<span class="number">2</span>*h<span class="number">-1</span>, arrA, arrB);</span><br><span class="line">    <span class="keyword">if</span>(i+h<span class="number">-1</span> &lt; arrA.size()<span class="number">-1</span>)  <span class="comment">//剩下元素个数大于一段,不足两段;</span></span><br><span class="line">        merge(i, i+h<span class="number">-1</span>, arrA.size()<span class="number">-1</span>, arrA, arrB);</span><br><span class="line">    <span class="keyword">else</span>                       <span class="comment">//剩下元素个数不足一段,直接拷贝;</span></span><br><span class="line">        <span class="keyword">for</span>(; i!=arrA.size(); ++i)</span><br><span class="line">            arrB[i] = arrA[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort_1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dev(arr.size());</span><br><span class="line">    <span class="keyword">while</span>(h &lt; arr.size())</span><br><span class="line">    &#123;</span><br><span class="line">        mergePass(h,arr,dev); <span class="comment">//从数组arr归并到数组dev;</span></span><br><span class="line">        h *= <span class="number">2</span>;</span><br><span class="line">        mergePass(h,dev,arr); <span class="comment">//从数组dev归并到数组arr;</span></span><br><span class="line">        h *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自顶向下的分治算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort_2</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arrA, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arrB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        mergeSort_2(low, mid, arrA, arrB);</span><br><span class="line">        mergeSort_2(mid+<span class="number">1</span>, high, arrA, arrB);</span><br><span class="line">        merge(low, mid, high, arrA, arrB);  <span class="comment">//二路归并;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = low; i &lt;= high; ++i)    <span class="comment">//拷贝回原数组;</span></span><br><span class="line">            arrA[i] = arrB[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort_2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dev(arr.size());</span><br><span class="line">    mergeSort_2(<span class="number">0</span>, arr.size()<span class="number">-1</span>, arr, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.计数排序"></a><strong>8.计数排序</strong></h2><h3 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h3><p>假设n个输入元素都是在0到k区间内的一个整数,对每一个元素x,统计小于等于x的元素个数,包括其本身,利用这一信息可直接将元素输出到数组中的正确位置上.</p>
<h3 id="算法流程-7"><a href="#算法流程-7" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、初始化辅助数组count[k],统计元素出现次数,如元素i用count[i]表示;<br>2、对于每一个元素,统计小于等于其本身的元素个数,即count[i]+=count[i-1];<br>3、反向扫描待排序数组,每扫描一项,将其存入临时数组dev中的第count[i]项,count[i]减一;<br>4、拷贝回原数组,排序完成.</p>
<h3 id="算法性能-7"><a href="#算法性能-7" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(k+n)$,空间$O(k+n)$ 算法稳定</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找出最大值;</span></span><br><span class="line">    <span class="keyword">if</span>(arr.empty())<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i != arr.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; max)</span><br><span class="line">            max = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计数;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(max+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dev(arr.size()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != arr.size(); ++i)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= max; ++i)</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将记录输出到正确位置,并复制回原数组;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        dev[count[arr[i]]--] = arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != arr.size(); ++i)</span><br><span class="line">        arr[i] = dev[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9.基数排序"></a><strong>9.基数排序</strong></h2><h3 id="算法思想-8"><a href="#算法思想-8" class="headerlink" title="算法思想"></a>算法思想</h3><p>通过对关键字的每一个分量使用一种稳定的排序方法,从低位到高位对序列进行排序.</p>
<h3 id="算法流程-8"><a href="#算法流程-8" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、将待排序记录装入一个队列A,设置10个初始空队列vector<queue<int>&gt; q(10);<br>2、从队列A中取出每个数据data,第pass遍处理时,考察data.key右起第pass位数字,设其为r,把data插入队列q[r]中;<br>3、从q[0]开始依次取出队列中的全部数据,并按照取出顺序插入到队列A中;<br>4、重复步骤1-3,对于关键字中有figure位数字的数据进行figure遍处理,排序完成.</queue<int></p>
<h3 id="算法关键"><a href="#算法关键" class="headerlink" title="算法关键"></a>算法关键</h3><p> 1、从低位到高位进行排序,如果要从高位排序,那么次高位的排序会影响高位已经排好的大小关系,所以数位按照影响力从低到高的顺序排序,数位影响力相同则比较数位值;<br> 2、同一数位排序必须采用稳定排序的方法,稳定排序能保证低位的排序成果能够被保留.</p>
<h3 id="算法性能-8"><a href="#算法性能-8" class="headerlink" title="算法性能"></a>算法性能</h3><p>设n为关键字个数,d为关键字分量个数,r为基数,若队列采用链表表示,则时间$O(d*(n+r))$,空间$O(n+r)$ 算法稳定</p>
<h3 id="算法优化-3"><a href="#算法优化-3" class="headerlink" title="算法优化"></a>算法优化</h3><p>每一个桶中存放多少个关键字分量相同的记录是未知的,因此队列的长度难以确定,故队列采用链表表示,分别设置队首、队尾指针,方便于收集数据.</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回关键字对应位数据;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">radix</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> power = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != p<span class="number">-1</span>; ++i)</span><br><span class="line">        power *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> value/power % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用桶的分配收集作为稳定排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort_1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> figure)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用队列保存;</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:arr)</span><br><span class="line">        A.push(num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序主代码;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pass=<span class="number">1</span>; pass &lt;= figure; ++pass)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; q(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">while</span>(!A.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> data = A.front();A.pop();</span><br><span class="line">            <span class="keyword">int</span> r = radix(data,pass);</span><br><span class="line">            q[r].push(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i!=<span class="number">10</span>; ++i)</span><br><span class="line">            <span class="keyword">while</span>(!q[i].empty())</span><br><span class="line">            &#123;</span><br><span class="line">                A.push(q[i].front());</span><br><span class="line">                q[i].pop();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写回原数组;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != arr.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = A.front();</span><br><span class="line">        A.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用计数排序作为稳定排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort_2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> figure)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> pass=<span class="number">1</span>; pass &lt;= figure; ++pass)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//分离关键字分量,找出最大值;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; comp(arr.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != arr.size(); ++i)</span><br><span class="line">            comp[i] = radix(arr[i], pass);</span><br><span class="line">        <span class="keyword">int</span> max = comp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i != arr.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(comp[i] &gt; max)</span><br><span class="line">                max = comp[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计数;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dev(arr.size()+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(max+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != arr.size(); ++i)</span><br><span class="line">            count[comp[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= max; ++i)</span><br><span class="line">            count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将记录输出到正确位置,并复制回原数组;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            dev[count[comp[i]]--] = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i != arr.size(); ++i)</span><br><span class="line">            arr[i] = dev[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-桶排序"><a href="#10-桶排序" class="headerlink" title="10.桶排序"></a><strong>10.桶排序</strong></h2><h3 id="算法思想-9"><a href="#算法思想-9" class="headerlink" title="算法思想"></a>算法思想</h3><p>假设输入数据服从均匀分布,基于某种映射规则,将待排序数据分别放入各个桶中,对各个桶中的数据进行排序,然后按照次序把各个桶中的元素放回原数组即可.</p>
<h3 id="算法流程-9"><a href="#算法流程-9" class="headerlink" title="算法流程"></a>算法流程</h3><p>1、建立映射规则;<br>2、将待排序数据分配到各个桶中;<br>3、对各个桶中的数据进行排序;<br>4、按照次序把各个桶中的元素放回原数组,排序完成.</p>
<h3 id="算法性能-9"><a href="#算法性能-9" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间$O(n)$,空间$O(n)$ 算法稳定<br>注:如果数据分布不均匀,当所有桶大小的平方和与总的元素个数成线性关系时,桶排序仍然可在线性时间内完成.</p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据映射关系把元素分配到各个桶中;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; buckets(<span class="number">101</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num:arr)</span><br><span class="line">        buckets[num/<span class="number">10</span>].push_back(num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对各个桶中数据进行直接插入排序;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;tmp:buckets)</span><br><span class="line">        insertSort(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照次序将各个桶中的数据写回原数组;</span></span><br><span class="line">    arr.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;tmp:buckets)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:tmp)</span><br><span class="line">            arr.push_back(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="排序算法考虑因素"><a href="#排序算法考虑因素" class="headerlink" title="排序算法考虑因素"></a>排序算法考虑因素</h3><p>1、时间复杂度<br>2、空间复杂度<br>3、稳定性<br>4、算法简单性<br>5、待排序记录个数n的大小<br>6、记录本身信息量的大小<br>7、关键字值的分布情况</p>
<h3 id="10种常见排序算法指标对比"><a href="#10种常见排序算法指标对比" class="headerlink" title="10种常见排序算法指标对比"></a>10种常见排序算法指标对比</h3><table>
<thead>
<tr>
<th>排序方法</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>是</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$/$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(logn)$~$O(n)$</td>
<td>否 2,2,1</td>
</tr>
<tr>
<td>插入排序</td>
<td>$O(n^2)$</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>是</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(nlogn)$</td>
<td>$O(n^(1.3))$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>否 3,2,2</td>
</tr>
<tr>
<td>选择排序</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(n^2)$</td>
<td>$O(1)$</td>
<td>否 2,2,1</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(1)$</td>
<td>否 1,2,2</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(nlogn)$</td>
<td>$O(n)$</td>
<td>是</td>
</tr>
<tr>
<td>计数排序</td>
<td>$O(k+n)$</td>
<td>$O(k+n)$</td>
<td>$O(k+n)$</td>
<td>$O(k+n)$</td>
<td>是</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(d*(n+r))$</td>
<td>$O(d*(n+r))$</td>
<td>$O(d*(n+r))$</td>
<td>$O(n+r)$</td>
<td>是</td>
</tr>
<tr>
<td>桶排序</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>？？？</td>
<td>？？？</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="附录：Python实现"><a href="#附录：Python实现" class="headerlink" title="附录：Python实现"></a>附录：<a href="https://github.com/zg-diligence/blog_contents/blob/master/10%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/%E9%99%84python%E5%AE%9E%E7%8E%B0.py" target="_blank" rel="noopener">Python实现</a></h2>]]></content>
      
        <categories>
            
            <category> 数据结构与算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sort </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
